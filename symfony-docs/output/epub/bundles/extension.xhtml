<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>How to Load Service Configuration inside a Bundle</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="how-to-load-service-configuration-inside-a-bundle">
<span id="index-0"></span><h1>How to Load Service Configuration inside a Bundle</h1>
<p>Services created by bundles are not defined in the main <code class="docutils literal notranslate"><span class="pre">config/services.yaml</span></code>
file used by the application but in the bundles themselves. This article
explains how to create and load service files using the bundle directory
structure.</p>
<div class="section" id="creating-an-extension-class">
<h2>Creating an Extension Class</h2>
<p>In order to load service configuration, you have to create a Dependency
Injection (DI) Extension for your bundle. By default, the Extension class must
follow these conventions (but later you’ll learn how to skip them if needed):</p>
<ul class="simple">
<li><p>It has to live in the <code class="docutils literal notranslate"><span class="pre">DependencyInjection</span></code> namespace of the bundle;</p></li>
<li><p>It has to implement the <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/Extension/ExtensionInterface.php" title="Symfony\Component\DependencyInjection\Extension\ExtensionInterface"><span class="pre">ExtensionInterface</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/Extension/ExtensionInterface.php]</span></span></code>,
which is usually achieved by extending the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/Extension/Extension.php" title="Symfony\Component\DependencyInjection\Extension\Extension"><span class="pre">Extension</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/Extension/Extension.php]</span></span></code> class;</p></li>
<li><p>The name is equal to the bundle name with the <code class="docutils literal notranslate"><span class="pre">Bundle</span></code> suffix replaced by
<code class="docutils literal notranslate"><span class="pre">Extension</span></code> (e.g. the Extension class of the AcmeBundle would be called
<code class="docutils literal notranslate"><span class="pre">AcmeExtension</span></code> and the one for AcmeHelloBundle would be called
<code class="docutils literal notranslate"><span class="pre">AcmeHelloExtension</span></code>).</p></li>
</ul>
<p>This is how the extension of an AcmeHelloBundle should look like:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/Acme/HelloBundle/DependencyInjection/AcmeHelloExtension.php</span>
<span class="k">namespace</span> <span class="nx">Acme\HelloBundle\DependencyInjection</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Extension\Extension</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AcmeHelloExtension</span> <span class="k">extends</span> <span class="nx">Extension</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$configs</span><span class="p">,</span> <span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ... you&#39;ll load the files here later</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="manually-registering-an-extension-class">
<h3>Manually Registering an Extension Class</h3>
<p>When not following the conventions, you will have to manually register your
extension. To do this, you should override the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpKernel/Bundle/Bundle.php" title="Symfony\Component\HttpKernel\Bundle\Bundle::build()"><span class="pre">Bundle::getContainerExtension()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpKernel/Bundle/Bundle.php]</span></span></code>
method to return the instance of the extension:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="k">use</span> <span class="nx">Acme\HelloBundle\DependencyInjection\UnconventionalExtensionClass</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AcmeHelloBundle</span> <span class="k">extends</span> <span class="nx">Bundle</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getContainerExtension</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">UnconventionalExtensionClass</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition, when the new Extension class name doesn’t follow the naming
conventions, you must also override the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/Extension/Extension.php" title="Symfony\Component\DependencyInjection\Extension\Extension::getAlias()"><span class="pre">Extension::getAlias()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/Extension/Extension.php]</span></span></code>
method to return the correct DI alias. The DI alias is the name used to refer to
the bundle in the container (e.g. in the <code class="docutils literal notranslate"><span class="pre">config/packages/</span></code> files). By
default, this is done by removing the <code class="docutils literal notranslate"><span class="pre">Extension</span></code> suffix and converting the
class name to underscores (e.g. <code class="docutils literal notranslate"><span class="pre">AcmeHelloExtension</span></code>’s DI alias is
<code class="docutils literal notranslate"><span class="pre">acme_hello</span></code>).</p>
</div>
</div>
<div class="section" id="using-the-load-method">
<h2>Using the <code class="docutils literal notranslate"><span class="pre">load()</span></code> Method</h2>
<p>In the <code class="docutils literal notranslate"><span class="pre">load()</span></code> method, all services and parameters related to this extension
will be loaded. This method doesn’t get the actual container instance, but a
copy. This container only has the parameters from the actual container. After
loading the services and parameters, the copy will be merged into the actual
container, to ensure all services and parameters are also added to the actual
container.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">load()</span></code> method, you can use PHP code to register service definitions,
but it is more common if you put these definitions in a configuration file
(using the YAML, XML or PHP format).</p>
<p>For instance, assume you have a file called <code class="docutils literal notranslate"><span class="pre">services.xml</span></code> in the
<code class="docutils literal notranslate"><span class="pre">Resources/config/</span></code> directory of your bundle, your <code class="docutils literal notranslate"><span class="pre">load()</span></code> method looks like:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Config\FileLocator</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Loader\XmlFileLoader</span><span class="p">;</span>

<span class="c1">// ...</span>
<span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$configs</span><span class="p">,</span> <span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nv">$loader</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XmlFileLoader</span><span class="p">(</span>
        <span class="nv">$container</span><span class="p">,</span>
        <span class="k">new</span> <span class="nx">FileLocator</span><span class="p">(</span><span class="no">__DIR__</span><span class="o">.</span><span class="s1">&#39;/../Resources/config&#39;</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="nv">$loader</span><span class="o">-&gt;</span><span class="na">load</span><span class="p">(</span><span class="s1">&#39;services.xml&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The other available loaders are <code class="docutils literal notranslate"><span class="pre">YamlFileLoader</span></code> and <code class="docutils literal notranslate"><span class="pre">PhpFileLoader</span></code>.</p>
<div class="section" id="using-configuration-to-change-the-services">
<h3>Using Configuration to Change the Services</h3>
<p>The Extension is also the class that handles the configuration for that
particular bundle (e.g. the configuration in <code class="docutils literal notranslate"><span class="pre">config/packages/&lt;bundle_alias&gt;.yaml</span></code>).
To read more about it, see the “<a class="reference internal" href="configuration.xhtml"><span class="doc">How to Create Friendly Configuration for a Bundle</span></a>” article.</p>
</div>
</div>
<div class="section" id="adding-classes-to-compile">
<h2>Adding Classes to Compile</h2>
<p>Bundles can hint Symfony about which of their classes contain annotations so
they are compiled when generating the application cache to improve the overall
performance. Define the list of annotated classes to compile in the
<code class="docutils literal notranslate"><span class="pre">addAnnotatedClassesToCompile()</span></code> method:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">public</span> <span class="k">function</span> <span class="nf">load</span><span class="p">(</span><span class="k">array</span> <span class="nv">$configs</span><span class="p">,</span> <span class="nx">ContainerBuilder</span> <span class="nv">$container</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">addAnnotatedClassesToCompile</span><span class="p">([</span>
        <span class="c1">// you can define the fully qualified class names...</span>
        <span class="s1">&#39;App\\Controller\\DefaultController&#39;</span><span class="p">,</span>
        <span class="c1">// ... but glob patterns are also supported:</span>
        <span class="s1">&#39;**Bundle\\Controller\\&#39;</span><span class="p">,</span>

        <span class="c1">// ...</span>
    <span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If some class extends from other classes, all its parents are automatically
included in the list of classes to compile.</p>
</div>
<p>Patterns are transformed into the actual class namespaces using the classmap
generated by Composer. Therefore, before using these patterns, you must generate
the full classmap executing the <code class="docutils literal notranslate"><span class="pre">dump-autoload</span></code> command of Composer.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>This technique can’t be used when the classes to compile use the <code class="docutils literal notranslate"><span class="pre">__DIR__</span></code>
or <code class="docutils literal notranslate"><span class="pre">__FILE__</span></code> constants, because their values will change when loading
these classes from the <code class="docutils literal notranslate"><span class="pre">classes.php</span></code> file.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>