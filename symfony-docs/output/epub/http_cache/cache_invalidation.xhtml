<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Cache Invalidation</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="cache-invalidation">
<span id="http-cache-invalidation"></span><span id="index-0"></span><h1>Cache Invalidation</h1>
<blockquote>
<div><p>“There are only two hard things in Computer Science: cache invalidation
and naming things.” – Phil Karlton</p>
</div></blockquote>
<p>Once a URL is cached by a gateway cache, the cache will not ask the
application for that content anymore. This allows the cache to provide fast
responses and reduces the load on your application. However, you risk
delivering outdated content. A way out of this dilemma is to use long
cache lifetimes, but to actively notify the gateway cache when content
changes. Reverse proxies usually provide a channel to receive such
notifications, typically through special HTTP requests.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>While cache invalidation is powerful, avoid it when possible. If you fail
to invalidate something, outdated caches will be served for a potentially
long time. Instead, use short cache lifetimes or use the validation model,
and adjust your controllers to perform efficient validation checks as
explained in <a class="reference internal" href="validation.xhtml#optimizing-cache-validation"><span class="std std-ref">Optimizing your Code with Validation</span></a>.</p>
<p>Furthermore, since invalidation is a topic specific to each type of reverse
proxy, using this concept will tie you to a specific reverse proxy or need
additional efforts to support different proxies.</p>
</div>
<p>Sometimes, however, you need that extra performance you can get when
explicitly invalidating. For invalidation, your application needs to detect
when content changes and tell the cache to remove the URLs which contain
that data from its cache.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you want to use cache invalidation, have a look at the
<a class="reference external" href="https://foshttpcachebundle.readthedocs.org/">FOSHttpCacheBundle</a><span class="link-target"> [https://foshttpcachebundle.readthedocs.org/]</span>. This bundle provides services to help with various
cache invalidation concepts and also documents the configuration for a
couple of common caching proxies.</p>
</div>
<p>If one content corresponds to one URL, the <code class="docutils literal notranslate"><span class="pre">PURGE</span></code> model works well.
You send a request to the cache proxy with the HTTP method <code class="docutils literal notranslate"><span class="pre">PURGE</span></code> (using
the word “PURGE” is a convention, technically this can be any string) instead
of <code class="docutils literal notranslate"><span class="pre">GET</span></code> and make the cache proxy detect this and remove the data from the
cache instead of going to the application to get a response.</p>
<p>Here is how you can configure the Symfony reverse proxy (See <a class="reference internal" href="../http_cache.xhtml"><span class="doc">HTTP Cache</span></a>)
to support the <code class="docutils literal notranslate"><span class="pre">PURGE</span></code> HTTP method:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/CacheKernel.php</span>
<span class="k">namespace</span> <span class="nx">App</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Request</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Response</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="k">class</span> <span class="nc">CacheKernel</span> <span class="k">extends</span> <span class="nx">HttpCache</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">invalidate</span><span class="p">(</span><span class="nx">Request</span> <span class="nv">$request</span><span class="p">,</span> <span class="nv">$catch</span> <span class="o">=</span> <span class="k">false</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;PURGE&#39;</span> <span class="o">!==</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getMethod</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">parent</span><span class="o">::</span><span class="na">invalidate</span><span class="p">(</span><span class="nv">$request</span><span class="p">,</span> <span class="nv">$catch</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;127.0.0.1&#39;</span> <span class="o">!==</span> <span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getClientIp</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">(</span>
                <span class="s1">&#39;Invalid HTTP method&#39;</span><span class="p">,</span>
                <span class="nx">Response</span><span class="o">::</span><span class="na">HTTP_BAD_REQUEST</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="nv">$response</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Response</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$this</span><span class="o">-&gt;</span><span class="na">getStore</span><span class="p">()</span><span class="o">-&gt;</span><span class="na">purge</span><span class="p">(</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">getUri</span><span class="p">()))</span> <span class="p">{</span>
            <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setStatusCode</span><span class="p">(</span><span class="nx">Response</span><span class="o">::</span><span class="na">HTTP_OK</span><span class="p">,</span> <span class="s1">&#39;Purged&#39;</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setStatusCode</span><span class="p">(</span><span class="nx">Response</span><span class="o">::</span><span class="na">HTTP_NOT_FOUND</span><span class="p">,</span> <span class="s1">&#39;Not found&#39;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>You must protect the <code class="docutils literal notranslate"><span class="pre">PURGE</span></code> HTTP method somehow to avoid random people
purging your cached data.</p>
</div>
<p><strong>Purge</strong> instructs the cache to drop a resource in <em>all its variants</em>
(according to the <code class="docutils literal notranslate"><span class="pre">Vary</span></code> header, see <a class="reference internal" href="cache_vary.xhtml"><span class="doc">Varying the Response for HTTP Cache</span></a>). An alternative to purging is
<strong>refreshing</strong> a content. Refreshing means that the caching proxy is
instructed to discard its local cache and fetch the content again. This way,
the new content is already available in the cache. The drawback of refreshing
is that variants are not invalidated.</p>
<p>In many applications, the same content bit is used on various pages with
different URLs. More flexible concepts exist for those cases:</p>
<ul class="simple">
<li><p><strong>Banning</strong> invalidates responses matching regular expressions on the
URL or other criteria;</p></li>
<li><p><strong>Cache tagging</strong> lets you add a tag for each content used in a response
so that you can invalidate all URLs containing a certain content.</p></li>
</ul>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>