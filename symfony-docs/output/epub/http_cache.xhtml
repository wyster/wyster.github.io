<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>HTTP Cache</title>
    <link rel="stylesheet" href="_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="http-cache">
<span id="index-0"></span><h1>HTTP Cache</h1>
<p>The nature of rich web applications means that they’re dynamic. No matter
how efficient your application, each request will always contain more overhead
than serving a static file. Usually, that’s fine. But when you need your requests
to be lightning fast, you need HTTP caching.</p>
<div class="section" id="caching-on-the-shoulders-of-giants">
<h2>Caching on the Shoulders of Giants</h2>
<p>With HTTP Caching, you cache the full output of a page (i.e. the response) and bypass
your application <em>entirely</em> on subsequent requests. Caching entire responses
isn’t always possible for highly dynamic sites, or is it? With
<a class="reference internal" href="http_cache/esi.xhtml"><span class="doc">Edge Side Includes (ESI)</span></a>, you can use the power of HTTP caching
on only <em>fragments</em> of your site.</p>
<p>The Symfony cache system is different because it relies on the simplicity
and power of the HTTP cache as defined in <a class="reference external" href="https://tools.ietf.org/html/rfc7234">RFC 7234 - Caching</a><span class="link-target"> [https://tools.ietf.org/html/rfc7234]</span>. Instead of
reinventing a caching methodology, Symfony embraces the standard that defines
basic communication on the Web. Once you understand the fundamental HTTP
validation and expiration caching models, you’ll be ready to master the Symfony
cache system.</p>
<p>Since caching with HTTP isn’t unique to Symfony, many articles already exist
on the topic. If you’re new to HTTP caching, Ryan Tomayko’s article
<a class="reference external" href="https://2ndscale.com/writings/things-caches-do">Things Caches Do</a><span class="link-target"> [https://2ndscale.com/writings/things-caches-do]</span> is <em>highly</em> recommended. Another in-depth resource is Mark
Nottingham’s <a class="reference external" href="https://www.mnot.net/cache_docs/">Cache Tutorial</a><span class="link-target"> [https://www.mnot.net/cache_docs/]</span>.</p>
</div>
<div class="section" id="caching-with-a-gateway-cache">
<span id="gateway-caches"></span><span id="index-1"></span><h2>Caching with a Gateway Cache</h2>
<p>When caching with HTTP, the <em>cache</em> is separated from your application entirely
and sits between your application and the client making the request.</p>
<p>The job of the cache is to accept requests from the client and pass them
back to your application. The cache will also receive responses back from
your application and forward them on to the client. The cache is the “middle-man”
of the request-response communication between the client and your application.</p>
<p>Along the way, the cache will store each response that is deemed “cacheable”
(See <a class="reference internal" href="#http-cache-introduction"><span class="std std-ref">Making your Responses HTTP Cacheable</span></a>). If the same resource is requested again,
the cache sends the cached response to the client, ignoring your application
entirely.</p>
<p>This type of cache is known as an HTTP gateway cache and many exist such
as <a class="reference external" href="https://varnish-cache.org/">Varnish</a><span class="link-target"> [https://varnish-cache.org/]</span>, <a class="reference external" href="https://wiki.squid-cache.org/SquidFaq/ReverseProxy">Squid in reverse proxy mode</a><span class="link-target"> [https://wiki.squid-cache.org/SquidFaq/ReverseProxy]</span>, and the Symfony reverse proxy.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Gateway caches are sometimes referred to as reverse proxy caches,
surrogate caches, or even HTTP accelerators.</p>
</div>
<div class="section" id="symfony-reverse-proxy">
<span id="symfony2-reverse-proxy"></span><span id="symfony-gateway-cache"></span><span id="index-2"></span><h3>Symfony Reverse Proxy</h3>
<p>Symfony comes with a reverse proxy (i.e. gateway cache) written in PHP.
<a class="reference internal" href="#http-cache-symfony-versus-varnish"><span class="std std-ref">It’s not a fully-featured reverse proxy cache like Varnish</span></a>,
but is a great way to start.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For details on setting up Varnish, see <a class="reference internal" href="http_cache/varnish.xhtml"><span class="doc">How to Use Varnish to Speed up my Website</span></a>.</p>
</div>
<p>To enable the proxy, first create a caching kernel:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/CacheKernel.php</span>
<span class="k">namespace</span> <span class="nx">App</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">CacheKernel</span> <span class="k">extends</span> <span class="nx">HttpCache</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Modify the code of your front controller to wrap the default kernel into the
caching kernel:</p>
<div class="highlight-diff notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span></span>// public/index.php

<span class="gi">+ use App\CacheKernel;</span>
use App\Kernel;

// ...
$kernel = new Kernel($_SERVER[&#39;APP_ENV&#39;], (bool) $_SERVER[&#39;APP_DEBUG&#39;]);
<span class="gi">+ // Wrap the default Kernel with the CacheKernel one in &#39;prod&#39; environment</span>
<span class="gi">+ if (&#39;prod&#39; === $kernel-&gt;getEnvironment()) {</span>
<span class="gi">+     $kernel = new CacheKernel($kernel);</span>
<span class="gi">+ }</span>

$request = Request::createFromGlobals();
// ...
</pre></div>
</td></tr></table></div>
<p>The caching kernel will immediately act as a reverse proxy: caching responses
from your application and returning them to the client.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>If you’re using the <a class="reference internal" href="reference/configuration/framework.xhtml#configuration-framework-http-method-override"><span class="std std-ref">framework.http_method_override</span></a>
option to read the HTTP method from a <code class="docutils literal notranslate"><span class="pre">_method</span></code> parameter, see the
above link for a tweak you need to make.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The cache kernel has a special <code class="docutils literal notranslate"><span class="pre">getLog()</span></code> method that returns a string
representation of what happened in the cache layer. In the development
environment, use it to debug and validate your cache strategy:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nb">error_log</span><span class="p">(</span><span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">getLog</span><span class="p">());</span>
</pre></div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CacheKernel</span></code> object has a sensible default configuration, but it can be
finely tuned via a set of options you can set by overriding the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/HttpCache/HttpCache.php" title="Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache::getOptions()"><span class="pre">getOptions()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/HttpCache/HttpCache.php]</span></span></code>
method:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/CacheKernel.php</span>
<span class="k">namespace</span> <span class="nx">App</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Bundle\FrameworkBundle\HttpCache\HttpCache</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">CacheKernel</span> <span class="k">extends</span> <span class="nx">HttpCache</span>
<span class="p">{</span>
    <span class="k">protected</span> <span class="k">function</span> <span class="nf">getOptions</span><span class="p">()</span><span class="o">:</span> <span class="k">array</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="s1">&#39;default_ttl&#39;</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="c1">// ...</span>
        <span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For a full list of the options and their meaning, see the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpKernel/HttpCache/HttpCache.php" title="Symfony\Component\HttpKernel\HttpCache\HttpCache::__construct()"><span class="pre">HttpCache::__construct()</span> <span class="pre">documentation</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpKernel/HttpCache/HttpCache.php]</span></span></code>.</p>
<p>When you’re in debug mode (the second argument of <code class="docutils literal notranslate"><span class="pre">Kernel</span></code> constructor in the
front controller is <code class="docutils literal notranslate"><span class="pre">true</span></code>), Symfony automatically adds an <code class="docutils literal notranslate"><span class="pre">X-Symfony-Cache</span></code>
header to the response. You can also use the <code class="docutils literal notranslate"><span class="pre">trace_level</span></code> config
option and set it to either <code class="docutils literal notranslate"><span class="pre">none</span></code>, <code class="docutils literal notranslate"><span class="pre">short</span></code> or <code class="docutils literal notranslate"><span class="pre">full</span></code> to
add this information.</p>
<p><code class="docutils literal notranslate"><span class="pre">short</span></code> will add the information for the master request only.
It’s written in a concise way that makes it easy to record the
information in your server log files. For example, in Apache you can
use <code class="docutils literal notranslate"><span class="pre">%{X-Symfony-Cache}o</span></code> in <code class="docutils literal notranslate"><span class="pre">LogFormat</span></code> format statements.
This information can be used to extract general information about
cache efficiency of your routes.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>You can change the name of the header used for the trace
information using the <code class="docutils literal notranslate"><span class="pre">trace_header</span></code> config option.</p>
</div>
<div class="sidebar" id="http-cache-symfony-versus-varnish">
<p class="sidebar-title">Changing from one Reverse Proxy to another</p>
<p>The Symfony reverse proxy is a great tool to use when developing your
website or when you deploy your website to a shared host where you cannot
install anything beyond PHP code. But being written in PHP, it cannot
be as fast as a proxy written in C.</p>
<p>Fortunately, since all reverse proxies are effectively the same, you should
be able to switch to something more robust - like Varnish - without any problems.
See <a class="reference internal" href="http_cache/varnish.xhtml"><span class="doc">How to use Varnish</span></a></p>
</div>
</div>
</div>
<div class="section" id="making-your-responses-http-cacheable">
<span id="http-cache-introduction"></span><span id="index-3"></span><h2>Making your Responses HTTP Cacheable</h2>
<p>Once you’ve added a reverse proxy cache (e.g. like the Symfony reverse proxy or Varnish),
you’re ready to cache your responses. To do that, you need to <em>communicate</em> to your
cache <em>which</em> responses are cacheable and for how long. This is done by setting HTTP
cache headers on the response.</p>
<p>HTTP specifies four response cache headers that you can set to enable caching:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Cache-Control</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Expires</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ETag</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Last-Modified</span></code></p></li>
</ul>
<p>These four headers are used to help cache your responses via <em>two</em> different models:</p>
<span id="http-expiration-validation"></span><ol class="arabic simple" id="http-expiration-and-validation">
<li><p><a class="reference internal" href="#http-cache-expiration-intro"><span class="std std-ref">Expiration Caching</span></a>
Used to cache your entire response for a specific amount of time (e.g. 24 hours).
Simple, but cache invalidation is more difficult.</p></li>
<li><p><a class="reference internal" href="#http-cache-validation-intro"><span class="std std-ref">Validation Caching</span></a>
More complex: used to cache your response, but allows you to dynamically invalidate
it as soon as your content changes.</p></li>
</ol>
<div class="sidebar">
<p class="sidebar-title">Reading the HTTP Specification</p>
<p>All of the HTTP headers you’ll read about are <em>not</em> invented by Symfony! They’re
part of an HTTP specification that’s used by sites all over the web. To dig deeper
into HTTP Caching, check out the documents <a class="reference external" href="https://tools.ietf.org/html/rfc7234">RFC 7234 - Caching</a><span class="link-target"> [https://tools.ietf.org/html/rfc7234]</span> and
<a class="reference external" href="https://tools.ietf.org/html/rfc7232">RFC 7232 - Conditional Requests</a><span class="link-target"> [https://tools.ietf.org/html/rfc7232]</span>.</p>
<p>As a web developer, you are strongly urged to read the specification. Its
clarity and power - even more than fifteen years after its creation - is
invaluable. Don’t be put-off by the appearance of the spec - its contents
are much more beautiful than its cover!</p>
</div>
<div class="section" id="expiration-caching">
<span id="http-cache-expiration-intro"></span><span id="index-4"></span><h3>Expiration Caching</h3>
<p>The <em>easiest</em> way to cache a response is by caching it for a specific amount of time:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/Controller/BlogController.php</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpFoundation\Response</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">index</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// somehow create a Response object, like by rendering a template</span>
    <span class="nv">$response</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">render</span><span class="p">(</span><span class="s1">&#39;blog/index.html.twig&#39;</span><span class="p">,</span> <span class="p">[]);</span>

    <span class="c1">// cache publicly for 3600 seconds</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setPublic</span><span class="p">();</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setMaxAge</span><span class="p">(</span><span class="mi">3600</span><span class="p">);</span>

    <span class="c1">// (optional) set a custom Cache-Control directive</span>
    <span class="nv">$response</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">addCacheControlDirective</span><span class="p">(</span><span class="s1">&#39;must-revalidate&#39;</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>

    <span class="k">return</span> <span class="nv">$response</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Thanks to this new code, your HTTP response will have the following header:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span>Cache-Control: public, maxage=3600, must-revalidate
</pre></div>
</td></tr></table></div>
<p>This tells your HTTP reverse proxy to cache this response for 3600 seconds. If <em>anyone</em>
requests this URL again before 3600 seconds, your application <em>won’t</em> be hit at all.
If you’re using the Symfony reverse proxy, look at the <code class="docutils literal notranslate"><span class="pre">X-Symfony-Cache</span></code> header
for debugging information about cache hits and misses.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The URI of the request is used as the cache key (unless you <a class="reference internal" href="http_cache/cache_vary.xhtml"><span class="doc">vary</span></a>).</p>
</div>
<p>This provides great performance and is simple to use. But, cache <em>invalidation</em>
is not supported. If your content change, you’ll need to wait until your cache
expires for the page to update.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Actually, you <em>can</em> manually invalidate your cache, but it’s not part of the
HTTP Caching spec. See <a class="reference internal" href="http_cache/cache_invalidation.xhtml#http-cache-invalidation"><span class="std std-ref">Cache Invalidation</span></a>.</p>
</div>
<p>If you need to set cache headers for many different controller actions, check out
<a class="reference external" href="https://foshttpcachebundle.readthedocs.org/">FOSHttpCacheBundle</a><span class="link-target"> [https://foshttpcachebundle.readthedocs.org/]</span>. It provides a way to define cache headers based on the URL
pattern and other request properties.</p>
<p>Finally, for more information about expiration caching, see <a class="reference internal" href="http_cache/expiration.xhtml"><span class="doc">HTTP Cache Expiration</span></a>.</p>
</div>
<div class="section" id="validation-caching">
<span id="http-cache-validation-intro"></span><h3>Validation Caching</h3>
<p id="index-5">With expiration caching, you say “cache for 3600 seconds!”. But, when someone
updates cached content, you won’t see that content on your site until the cache
expires.</p>
<p>If you need to see updated content <em>immediately</em>, you either need to
<a class="reference internal" href="http_cache/cache_invalidation.xhtml#http-cache-invalidation"><span class="std std-ref">invalidate</span></a> your cache <em>or</em> use the validation
caching model.</p>
<p>For details, see <a class="reference internal" href="http_cache/validation.xhtml"><span class="doc">HTTP Cache Validation</span></a>.</p>
</div>
<div class="section" id="safe-methods-only-caching-get-or-head-requests">
<span id="index-6"></span><h3>Safe Methods: Only caching GET or HEAD requests</h3>
<p>HTTP caching only works for “safe” HTTP methods (like GET and HEAD). This means
three things:</p>
<ul class="simple">
<li><p>Don’t try to cache PUT or DELETE requests. It won’t work and with good reason.
These methods are meant to be used when mutating the state of your application
(e.g. deleting a blog post). Caching them would prevent certain requests from hitting
and mutating your application.</p></li>
<li><p>POST requests are generally considered uncacheable, but <a class="reference external" href="https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-20#section-2.3.4">they can be cached</a><span class="link-target"> [https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-20#section-2.3.4]</span>
when they include explicit freshness information. However, POST caching is not
widely implemented, so you should avoid it if possible.</p></li>
<li><p>You should <em>never</em> change the state of your application (e.g. update a blog post)
when responding to a GET or HEAD request. If those requests are cached, future
requests may not actually hit your server.</p></li>
</ul>
</div>
<div class="section" id="more-response-methods">
<span id="index-7"></span><h3>More Response Methods</h3>
<p>The Response class provides many more methods related to the cache. Here are
the most useful ones:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// marks the Response stale</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">expire</span><span class="p">();</span>

<span class="c1">// forces the response to return a proper 304 response with no content</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setNotModified</span><span class="p">();</span>
</pre></div>
</div>
<p>Additionally, most cache-related HTTP headers can be set via the single
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Response.php" title="Symfony\Component\HttpFoundation\Response::setCache()"><span class="pre">setCache()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Response.php]</span></span></code> method:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// use this method to set several cache settings in one call</span>
<span class="c1">// (this example lists all the available cache settings)</span>
<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">setCache</span><span class="p">([</span>
    <span class="s1">&#39;must_revalidate&#39;</span>  <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
    <span class="s1">&#39;no_cache&#39;</span>         <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
    <span class="s1">&#39;no_store&#39;</span>         <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
    <span class="s1">&#39;no_transform&#39;</span>     <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
    <span class="s1">&#39;public&#39;</span>           <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
    <span class="s1">&#39;private&#39;</span>          <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
    <span class="s1">&#39;proxy_revalidate&#39;</span> <span class="o">=&gt;</span> <span class="k">false</span><span class="p">,</span>
    <span class="s1">&#39;max_age&#39;</span>          <span class="o">=&gt;</span> <span class="mi">600</span><span class="p">,</span>
    <span class="s1">&#39;s_maxage&#39;</span>         <span class="o">=&gt;</span> <span class="mi">600</span><span class="p">,</span>
    <span class="s1">&#39;immutable&#39;</span>        <span class="o">=&gt;</span> <span class="k">true</span><span class="p">,</span>
    <span class="s1">&#39;last_modified&#39;</span>    <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">\DateTime</span><span class="p">(),</span>
    <span class="s1">&#39;etag&#39;</span>             <span class="o">=&gt;</span> <span class="s1">&#39;abcdef&#39;</span>
<span class="p">]);</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 5.1: </span>The <code class="docutils literal notranslate"><span class="pre">must_revalidate</span></code>, <code class="docutils literal notranslate"><span class="pre">no_cache</span></code>, <code class="docutils literal notranslate"><span class="pre">no_store</span></code>, <code class="docutils literal notranslate"><span class="pre">no_transform</span></code> and
<code class="docutils literal notranslate"><span class="pre">proxy_revalidate</span></code> directives were introduced in Symfony 5.1.</p>
</div>
</div>
</div>
<div class="section" id="cache-invalidation">
<h2>Cache Invalidation</h2>
<p>Cache invalidation is <em>not</em> part of the HTTP specification. Still, it can be really
useful to delete various HTTP cache entries as soon as some content on your site
is updated.</p>
<p>For details, see <a class="reference internal" href="http_cache/cache_invalidation.xhtml"><span class="doc">Cache Invalidation</span></a>.</p>
</div>
<div class="section" id="using-edge-side-includes">
<h2>Using Edge Side Includes</h2>
<p>When pages contain dynamic parts, you may not be able to cache entire pages,
but only parts of it. Read <a class="reference internal" href="http_cache/esi.xhtml"><span class="doc">Working with Edge Side Includes</span></a> to find out how to configure
different cache strategies for specific parts of your page.</p>
</div>
<div class="section" id="http-caching-and-user-sessions">
<h2>HTTP Caching and User Sessions</h2>
<p>Whenever the session is started during a request, Symfony turns the response
into a private non-cacheable response. This is the best default behavior to not
cache private user information (e.g. a shopping cart, a user profile details,
etc.) and expose it to other visitors.</p>
<p>However, even requests making use of the session can be cached under some
circumstances. For example, information related to some user group could be
cached for all the users belonging to that group. Handling these advanced
caching scenarios is out of the scope of Symfony, but they can be solved with
the <a class="reference external" href="https://foshttpcachebundle.readthedocs.org/">FOSHttpCacheBundle</a><span class="link-target"> [https://foshttpcachebundle.readthedocs.org/]</span>.</p>
<p>In order to disable the default Symfony behavior that makes requests using the
session uncacheable, add the following internal header to your response and
Symfony won’t modify it:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\HttpKernel\EventListener\AbstractSessionListener</span><span class="p">;</span>

<span class="nv">$response</span><span class="o">-&gt;</span><span class="na">headers</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="nx">AbstractSessionListener</span><span class="o">::</span><span class="na">NO_AUTO_CACHE_CONTROL_HEADER</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>Symfony was designed to follow the proven rules of the road: HTTP. Caching
is no exception. Mastering the Symfony cache system means becoming familiar
with the HTTP cache models and using them effectively. This means that, instead
of relying only on Symfony documentation and code examples, you have access
to a world of knowledge related to HTTP caching and gateway caches such as
Varnish.</p>
</div>
<div class="section" id="learn-more">
<h2>Learn more</h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="http_cache/cache_invalidation.xhtml">Cache Invalidation</a></li>
<li class="toctree-l1"><a class="reference internal" href="http_cache/cache_vary.xhtml">Varying the Response for HTTP Cache</a></li>
<li class="toctree-l1"><a class="reference internal" href="http_cache/esi.xhtml">Working with Edge Side Includes</a></li>
<li class="toctree-l1"><a class="reference internal" href="http_cache/expiration.xhtml">HTTP Cache Expiration</a></li>
<li class="toctree-l1"><a class="reference internal" href="http_cache/ssi.xhtml">Working with Server Side Includes</a></li>
<li class="toctree-l1"><a class="reference internal" href="http_cache/validation.xhtml">HTTP Cache Validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="http_cache/varnish.xhtml">How to Use Varnish to Speed up my Website</a></li>
</ul>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>