<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Container Building Workflow</title>
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="container-building-workflow">
<span id="index-0"></span><h1>Container Building Workflow</h1>
<p>The location of the files and classes related to the Dependency Injection
component depends on the application, library or framework in which you want
to use the container. Looking at how the container is configured and built
in the Symfony full-stack Framework will help you see how this all fits together,
whether you are using the full-stack framework or looking to use the service
container in another application.</p>
<p>The full-stack framework uses the HttpKernel component to manage the loading
of the service container configuration from the application and bundles
and also handles the compilation and caching. Even if you are not using
HttpKernel, it should give you an idea of one way of organizing configuration
in a modular application.</p>
<div class="section" id="working-with-a-cached-container">
<h2>Working with a Cached Container</h2>
<p>Before building it, the kernel checks to see if a cached version of the
container exists. The HttpKernel has a debug setting and if this is false,
the cached version is used if it exists. If debug is true then the kernel
<a class="reference internal" href="../config/caching.xhtml"><span class="doc">checks to see if configuration is fresh</span></a>
and if it is, the cached version of the container is used. If not then the
container is built from the application-level configuration and the bundles’s
extension configuration.</p>
<p>Read <a class="reference internal" href="compilation.xhtml#components-dependency-injection-dumping"><span class="std std-ref">Dumping the Configuration for Performance</span></a>
for more details.</p>
</div>
<div class="section" id="application-level-configuration">
<h2>Application-level Configuration</h2>
<p>Application level config is loaded from the <code class="docutils literal notranslate"><span class="pre">config</span></code> directory. Multiple
files are loaded which are then merged when the extensions are processed.
This allows for different configuration for different environments e.g.
dev, prod.</p>
<p>These files contain parameters and services that are loaded directly into
the container as per
<a class="reference internal" href="../dependency_injection.xhtml#components-dependency-injection-loading-config"><span class="std std-ref">Setting Up the Container with Configuration Files</span></a>.
They also contain configuration that is processed by extensions as per
<a class="reference internal" href="compilation.xhtml#components-dependency-injection-extension"><span class="std std-ref">Managing Configuration with Extensions</span></a>.
These are considered to be bundle configuration since each bundle contains
an Extension class.</p>
</div>
<div class="section" id="bundle-level-configuration-with-extensions">
<h2>Bundle-level Configuration with Extensions</h2>
<p>By convention, each bundle contains an Extension class which is in the bundle’s
<code class="docutils literal notranslate"><span class="pre">DependencyInjection</span></code> directory. These are registered with the <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code>
when the kernel is booted. When the <code class="docutils literal notranslate"><span class="pre">ContainerBuilder</span></code> is
<a class="reference internal" href="compilation.xhtml"><span class="doc">compiled</span></a>, the application-level
configuration relevant to the bundle’s extension is passed to the Extension
which also usually loads its own config file(s), typically from the bundle’s
<code class="docutils literal notranslate"><span class="pre">Resources/config</span></code> directory. The application-level config is usually
processed with a <a class="reference internal" href="../config/definition.xhtml"><span class="doc">Configuration object</span></a>
also stored in the bundle’s <code class="docutils literal notranslate"><span class="pre">DependencyInjection</span></code> directory.</p>
</div>
<div class="section" id="compiler-passes-to-allow-interaction-between-bundles">
<h2>Compiler Passes to Allow Interaction between Bundles</h2>
<p><a class="reference internal" href="compilation.xhtml#components-dependency-injection-compiler-passes"><span class="std std-ref">Compiler passes</span></a>
are used to allow interaction between different bundles as they cannot affect
each other’s configuration in the extension classes. One of the main uses
is to process tagged services, allowing bundles to register services to
be picked up by other bundles, such as Monolog loggers, Twig extensions
and Data Collectors for the Web Profiler. Compiler passes are usually placed
in the bundle’s <code class="docutils literal notranslate"><span class="pre">DependencyInjection/Compiler</span></code> directory.</p>
</div>
<div class="section" id="compilation-and-caching">
<h2>Compilation and Caching</h2>
<p>After the compilation process has loaded the services from the configuration,
extensions and the compiler passes, it is dumped so that the cache can be
used next time. The dumped version is then used during subsequent requests
as it is more efficient.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>