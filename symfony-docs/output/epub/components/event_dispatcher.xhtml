<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>The EventDispatcher Component</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-eventdispatcher-component">
<span id="index-0"></span><h1>The EventDispatcher Component</h1>
<blockquote>
<div><p>The EventDispatcher component provides tools that allow your application
components to communicate with each other by dispatching events and
listening to them.</p>
</div></blockquote>
<div class="section" id="introduction">
<h2>Introduction</h2>
<p>Object-oriented code has gone a long way to ensuring code extensibility.
By creating classes that have well-defined responsibilities, your code becomes
more flexible and a developer can extend them with subclasses to modify
their behaviors. But if they want to share the changes with other developers
who have also made their own subclasses, code inheritance is no longer the
answer.</p>
<p>Consider the real-world example where you want to provide a plugin system
for your project. A plugin should be able to add methods, or do something
before or after a method is executed, without interfering with other plugins.
This is not an easy problem to solve with single inheritance, and even if
multiple inheritance was possible with PHP, it comes with its own drawbacks.</p>
<p>The Symfony EventDispatcher component implements the <a class="reference external" href="https://en.wikipedia.org/wiki/Mediator_pattern">Mediator</a><span class="link-target"> [https://en.wikipedia.org/wiki/Mediator_pattern]</span> and <a class="reference external" href="https://en.wikipedia.org/wiki/Observer_pattern">Observer</a><span class="link-target"> [https://en.wikipedia.org/wiki/Observer_pattern]</span>
design patterns to make all these things possible and to make your projects
truly extensible.</p>
<p>Take an example from <a class="reference internal" href="http_kernel.xhtml"><span class="doc">the HttpKernel component</span></a>.
Once a <code class="docutils literal notranslate"><span class="pre">Response</span></code> object has been created, it may be useful to allow other
elements in the system to modify it (e.g. add some cache headers) before
it’s actually used. To make this possible, the Symfony kernel throws an
event - <code class="docutils literal notranslate"><span class="pre">kernel.response</span></code>. Here’s how it works:</p>
<ul class="simple">
<li><p>A <em>listener</em> (PHP object) tells a central <em>dispatcher</em> object that it
wants to listen to the <code class="docutils literal notranslate"><span class="pre">kernel.response</span></code> event;</p></li>
<li><p>At some point, the Symfony kernel tells the <em>dispatcher</em> object to dispatch
the <code class="docutils literal notranslate"><span class="pre">kernel.response</span></code> event, passing with it an <code class="docutils literal notranslate"><span class="pre">Event</span></code> object that
has access to the <code class="docutils literal notranslate"><span class="pre">Response</span></code> object;</p></li>
<li><p>The dispatcher notifies (i.e. calls a method on) all listeners of the
<code class="docutils literal notranslate"><span class="pre">kernel.response</span></code> event, allowing each of them to make modifications
to the <code class="docutils literal notranslate"><span class="pre">Response</span></code> object.</p></li>
</ul>
</div>
<div class="section" id="installation">
<span id="index-1"></span><h2>Installation</h2>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> composer require symfony/event-dispatcher
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you install this component outside of a Symfony application, you must
require the <code class="docutils literal notranslate"><span class="pre">vendor/autoload.php</span></code> file in your code to enable the class
autoloading mechanism provided by Composer. Read
<a class="reference internal" href="using_components.xhtml"><span class="doc">this article</span></a> for more details.</p>
</div>
</div>
<div class="section" id="usage">
<h2>Usage</h2>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>This article explains how to use the EventDispatcher features as an
independent component in any PHP application. Read the <a class="reference internal" href="../event_dispatcher.xhtml"><span class="doc">Events and Event Listeners</span></a>
article to learn about how to use it in Symfony applications.</p>
</div>
<div class="section" id="events">
<h3>Events</h3>
<p>When an event is dispatched, it’s identified by a unique name (e.g.
<code class="docutils literal notranslate"><span class="pre">kernel.response</span></code>), which any number of listeners might be listening to.
An <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/EventDispatcher/Event.php" title="Symfony\Contracts\EventDispatcher\Event"><span class="pre">Event</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/EventDispatcher/Event.php]</span></span></code> instance is also
created and passed to all of the listeners. As you’ll see later, the <code class="docutils literal notranslate"><span class="pre">Event</span></code>
object itself often contains data about the event being dispatched.</p>
<div class="section" id="naming-conventions">
<span id="index-2"></span><h4>Naming Conventions</h4>
<p>The unique event name can be any string, but optionally follows a few
naming conventions:</p>
<ul class="simple">
<li><p>Use only lowercase letters, numbers, dots (<code class="docutils literal notranslate"><span class="pre">.</span></code>) and underscores (<code class="docutils literal notranslate"><span class="pre">_</span></code>);</p></li>
<li><p>Prefix names with a namespace followed by a dot (e.g. <code class="docutils literal notranslate"><span class="pre">order.*</span></code>, <code class="docutils literal notranslate"><span class="pre">user.*</span></code>);</p></li>
<li><p>End names with a verb that indicates what action has been taken (e.g.
<code class="docutils literal notranslate"><span class="pre">order.placed</span></code>).</p></li>
</ul>
</div>
<div class="section" id="event-names-and-event-objects">
<span id="index-3"></span><h4>Event Names and Event Objects</h4>
<p>When the dispatcher notifies listeners, it passes an actual <code class="docutils literal notranslate"><span class="pre">Event</span></code> object
to those listeners. The base <code class="docutils literal notranslate"><span class="pre">Event</span></code> class contains a method for stopping
<a class="reference internal" href="#event-dispatcher-event-propagation"><span class="std std-ref">event propagation</span></a>, but not much
else.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Read “<a class="reference internal" href="event_dispatcher/generic_event.xhtml"><span class="doc">The Generic Event Object</span></a>” for more
information about this base event object.</p>
</div>
<p>Often times, data about a specific event needs to be passed along with the
<code class="docutils literal notranslate"><span class="pre">Event</span></code> object so that the listeners have the needed information. In such
case, a special subclass that has additional methods for retrieving and
overriding information can be passed when dispatching an event. For example,
the <code class="docutils literal notranslate"><span class="pre">kernel.response</span></code> event uses a
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpKernel/Event/ResponseEvent.php" title="Symfony\Component\HttpKernel\Event\ResponseEvent"><span class="pre">ResponseEvent</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpKernel/Event/ResponseEvent.php]</span></span></code>, which
contains methods to get and even replace the <code class="docutils literal notranslate"><span class="pre">Response</span></code> object.</p>
</div>
</div>
<div class="section" id="the-dispatcher">
<h3>The Dispatcher</h3>
<p>The dispatcher is the central object of the event dispatcher system. In
general, a single dispatcher is created, which maintains a registry of
listeners. When an event is dispatched via the dispatcher, it notifies all
listeners registered with that event:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\EventDispatcher</span><span class="p">;</span>

<span class="nv">$dispatcher</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">EventDispatcher</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="connecting-listeners">
<span id="index-4"></span><h3>Connecting Listeners</h3>
<p>To take advantage of an existing event, you need to connect a listener to
the dispatcher so that it can be notified when the event is dispatched.
A call to the dispatcher’s <code class="docutils literal notranslate"><span class="pre">addListener()</span></code> method associates any valid
PHP callable to an event:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$listener</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AcmeListener</span><span class="p">();</span>
<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">addListener</span><span class="p">(</span><span class="s1">&#39;acme.foo.action&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nv">$listener</span><span class="p">,</span> <span class="s1">&#39;onFooAction&#39;</span><span class="p">]);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">addListener()</span></code> method takes up to three arguments:</p>
<ol class="arabic simple">
<li><p>The event name (string) that this listener wants to listen to;</p></li>
<li><p>A PHP callable that will be executed when the specified event is dispatched;</p></li>
<li><p>An optional priority, defined as a positive or negative integer (defaults to
<code class="docutils literal notranslate"><span class="pre">0</span></code>). The higher the number, the earlier the listener is called. If two
listeners have the same priority, they are executed in the order that they
were added to the dispatcher.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A <a class="reference external" href="https://www.php.net/manual/en/language.types.callable.php">PHP callable</a><span class="link-target"> [https://www.php.net/manual/en/language.types.callable.php]</span> is a PHP variable that can be used by the
<code class="docutils literal notranslate"><span class="pre">call_user_func()</span></code> function and returns <code class="docutils literal notranslate"><span class="pre">true</span></code> when passed to the
<code class="docutils literal notranslate"><span class="pre">is_callable()</span></code> function. It can be a <code class="docutils literal notranslate"><span class="pre">\Closure</span></code> instance, an object
implementing an <code class="docutils literal notranslate"><span class="pre">__invoke()</span></code> method (which is what closures are in fact),
a string representing a function or an array representing an object
method or a class method.</p>
<p>So far, you’ve seen how PHP objects can be registered as listeners.
You can also register PHP <a class="reference external" href="https://www.php.net/manual/en/functions.anonymous.php">Closures</a><span class="link-target"> [https://www.php.net/manual/en/functions.anonymous.php]</span> as event listeners:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Contracts\EventDispatcher\Event</span><span class="p">;</span>

<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">addListener</span><span class="p">(</span><span class="s1">&#39;acme.foo.action&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">Event</span> <span class="nv">$event</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// will be executed when the acme.foo.action event is dispatched</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<p>Once a listener is registered with the dispatcher, it waits until the event
is notified. In the above example, when the <code class="docutils literal notranslate"><span class="pre">acme.foo.action</span></code> event is dispatched,
the dispatcher calls the <code class="docutils literal notranslate"><span class="pre">AcmeListener::onFooAction()</span></code> method and passes
the <code class="docutils literal notranslate"><span class="pre">Event</span></code> object as the single argument:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Contracts\EventDispatcher\Event</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AcmeListener</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">onFooAction</span><span class="p">(</span><span class="nx">Event</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ... do something</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">$event</span></code> argument is the event object that was passed when dispatching the
event. In many cases, a special event subclass is passed with extra
information. You can check the documentation or implementation of each event to
determine which instance is passed.</p>
<div class="sidebar">
<p class="sidebar-title">Registering Event Listeners and Subscribers in the Service Container</p>
<p>Registering service definitions and tagging them with the
<code class="docutils literal notranslate"><span class="pre">kernel.event_listener</span></code> and <code class="docutils literal notranslate"><span class="pre">kernel.event_subscriber</span></code> tags is not enough
to enable the event listeners and event subscribers. You must also register
a compiler pass called <code class="docutils literal notranslate"><span class="pre">RegisterListenersPass()</span></code> in the container builder:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ParameterBag\ParameterBag</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Reference</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\EventDispatcher</span><span class="p">;</span>

<span class="nv">$containerBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">(</span><span class="k">new</span> <span class="nx">ParameterBag</span><span class="p">());</span>
<span class="c1">// register the compiler pass that handles the &#39;kernel.event_listener&#39;</span>
<span class="c1">// and &#39;kernel.event_subscriber&#39; service tags</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">addCompilerPass</span><span class="p">(</span><span class="k">new</span> <span class="nx">RegisterListenersPass</span><span class="p">());</span>

<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">&#39;event_dispatcher&#39;</span><span class="p">,</span> <span class="nx">EventDispatcher</span><span class="o">::</span><span class="na">class</span><span class="p">);</span>

<span class="c1">// registers an event listener</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">&#39;listener_service_id&#39;</span><span class="p">,</span> <span class="nx">\AcmeListener</span><span class="o">::</span><span class="na">class</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">addTag</span><span class="p">(</span><span class="s1">&#39;kernel.event_listener&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="s1">&#39;event&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;acme.foo.action&#39;</span><span class="p">,</span>
        <span class="s1">&#39;method&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;onFooAction&#39;</span><span class="p">,</span>
    <span class="p">]);</span>

<span class="c1">// registers an event subscriber</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">&#39;subscriber_service_id&#39;</span><span class="p">,</span> <span class="nx">\AcmeSubscriber</span><span class="o">::</span><span class="na">class</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">addTag</span><span class="p">(</span><span class="s1">&#39;kernel.event_subscriber&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">RegisterListenersPass</span></code> resolves aliased class names which for instance
allows to refer to an event via the fully qualified class name (FQCN) of the
event class. The pass will read the alias mapping from a dedicated container
parameter. This parameter can be extended by registering another compiler pass,
<code class="docutils literal notranslate"><span class="pre">AddEventAliasesPass</span></code>:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Compiler\PassConfig</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ContainerBuilder</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\ParameterBag\ParameterBag</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\DependencyInjection\Reference</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\DependencyInjection\AddEventAliasesPass</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\EventDispatcher</span><span class="p">;</span>

<span class="nv">$containerBuilder</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ContainerBuilder</span><span class="p">(</span><span class="k">new</span> <span class="nx">ParameterBag</span><span class="p">());</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">addCompilerPass</span><span class="p">(</span><span class="k">new</span> <span class="nx">AddEventAliasesPass</span><span class="p">([</span>
    <span class="nx">\AcmeFooActionEvent</span><span class="o">::</span><span class="na">class</span> <span class="o">=&gt;</span> <span class="s1">&#39;acme.foo.action&#39;</span><span class="p">,</span>
<span class="p">]));</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">addCompilerPass</span><span class="p">(</span><span class="k">new</span> <span class="nx">RegisterListenersPass</span><span class="p">(),</span> <span class="nx">PassConfig</span><span class="o">::</span><span class="na">TYPE_BEFORE_REMOVING</span><span class="p">)</span>

<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">&#39;event_dispatcher&#39;</span><span class="p">,</span> <span class="nx">EventDispatcher</span><span class="o">::</span><span class="na">class</span><span class="p">);</span>

<span class="c1">// registers an event listener</span>
<span class="nv">$containerBuilder</span><span class="o">-&gt;</span><span class="na">register</span><span class="p">(</span><span class="s1">&#39;listener_service_id&#39;</span><span class="p">,</span> <span class="nx">\AcmeListener</span><span class="o">::</span><span class="na">class</span><span class="p">)</span>
    <span class="o">-&gt;</span><span class="na">addTag</span><span class="p">(</span><span class="s1">&#39;kernel.event_listener&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="c1">// will be translated to &#39;acme.foo.action&#39; by RegisterListenersPass.</span>
        <span class="s1">&#39;event&#39;</span> <span class="o">=&gt;</span> <span class="nx">\AcmeFooActionEvent</span><span class="o">::</span><span class="na">class</span><span class="p">,</span>
        <span class="s1">&#39;method&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;onFooAction&#39;</span><span class="p">,</span>
    <span class="p">]);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">AddEventAliasesPass</span></code> has to be processed before <code class="docutils literal notranslate"><span class="pre">RegisterListenersPass</span></code>.</p>
</div>
<p>By default, the listeners pass assumes that the event dispatcher’s service
id is <code class="docutils literal notranslate"><span class="pre">event_dispatcher</span></code>, that event listeners are tagged with the
<code class="docutils literal notranslate"><span class="pre">kernel.event_listener</span></code> tag, that event subscribers are tagged
with the <code class="docutils literal notranslate"><span class="pre">kernel.event_subscriber</span></code> tag and that the alias mapping is
stored as parameter <code class="docutils literal notranslate"><span class="pre">event_dispatcher.event_aliases</span></code>. You can change these
default values by passing custom values to the constructors of
<code class="docutils literal notranslate"><span class="pre">RegisterListenersPass</span></code> and <code class="docutils literal notranslate"><span class="pre">AddEventAliasesPass</span></code>.</p>
</div>
<span class="target" id="event-dispatcher-closures-as-listeners"></span></div>
<div class="section" id="creating-and-dispatching-an-event">
<span id="index-5"></span><h3>Creating and Dispatching an Event</h3>
<p>In addition to registering listeners with existing events, you can create
and dispatch your own events. This is useful when creating third-party
libraries and also when you want to keep different components of your own
system flexible and decoupled.</p>
<div class="section" id="creating-an-event-class">
<span id="creating-an-event-object"></span><h4>Creating an Event Class</h4>
<p>Suppose you want to create a new event - <code class="docutils literal notranslate"><span class="pre">order.placed</span></code> - that is dispatched
each time a customer orders a product with your application. When dispatching
this event, you’ll pass a custom event instance that has access to the placed
order. Start by creating this custom event class and documenting it:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="nx">Acme\Store\Event</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Acme\Store\Order</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Contracts\EventDispatcher\Event</span><span class="p">;</span>

<span class="sd">/**</span>
<span class="sd"> * The order.placed event is dispatched each time an order is created</span>
<span class="sd"> * in the system.</span>
<span class="sd"> */</span>
<span class="k">class</span> <span class="nc">OrderPlacedEvent</span> <span class="k">extends</span> <span class="nx">Event</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">const</span> <span class="no">NAME</span> <span class="o">=</span> <span class="s1">&#39;order.placed&#39;</span><span class="p">;</span>

    <span class="k">protected</span> <span class="nv">$order</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">Order</span> <span class="nv">$order</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">order</span> <span class="o">=</span> <span class="nv">$order</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getOrder</span><span class="p">()</span><span class="o">:</span> <span class="nx">Order</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">order</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each listener now has access to the order via the <code class="docutils literal notranslate"><span class="pre">getOrder()</span></code> method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you don’t need to pass any additional data to the event listeners, you
can also use the default
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/EventDispatcher/Event.php" title="Symfony\Contracts\EventDispatcher\Event"><span class="pre">Event</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/EventDispatcher/Event.php]</span></span></code> class. In such case,
you can document the event and its name in a generic <code class="docutils literal notranslate"><span class="pre">StoreEvents</span></code> class,
similar to the <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpKernel/KernelEvents.php" title="Symfony\Component\HttpKernel\KernelEvents"><span class="pre">KernelEvents</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpKernel/KernelEvents.php]</span></span></code>
class.</p>
</div>
</div>
<div class="section" id="dispatch-the-event">
<h4>Dispatch the Event</h4>
<p>The <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/EventDispatcher/EventDispatcher.php" title="Symfony\Component\EventDispatcher\EventDispatcher::dispatch()"><span class="pre">dispatch()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/EventDispatcher/EventDispatcher.php]</span></span></code>
method notifies all listeners of the given event. It takes two arguments:
the <code class="docutils literal notranslate"><span class="pre">Event</span></code> instance to pass to each listener of that event and the name
of the event to dispatch:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Acme\Store\Event\OrderPlacedEvent</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Acme\Store\Order</span><span class="p">;</span>

<span class="c1">// the order is somehow created or retrieved</span>
<span class="nv">$order</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Order</span><span class="p">();</span>
<span class="c1">// ...</span>

<span class="c1">// creates the OrderPlacedEvent and dispatches it</span>
<span class="nv">$event</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OrderPlacedEvent</span><span class="p">(</span><span class="nv">$order</span><span class="p">);</span>
<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="nv">$event</span><span class="p">,</span> <span class="nx">OrderPlacedEvent</span><span class="o">::</span><span class="na">NAME</span><span class="p">);</span>
</pre></div>
</div>
<p>Notice that the special <code class="docutils literal notranslate"><span class="pre">OrderPlacedEvent</span></code> object is created and passed to
the <code class="docutils literal notranslate"><span class="pre">dispatch()</span></code> method. Now, any listener to the <code class="docutils literal notranslate"><span class="pre">order.placed</span></code>
event will receive the <code class="docutils literal notranslate"><span class="pre">OrderPlacedEvent</span></code>.</p>
</div>
</div>
<div class="section" id="using-event-subscribers">
<span id="event-dispatcher-using-event-subscribers"></span><span id="index-6"></span><h3>Using Event Subscribers</h3>
<p>The most common way to listen to an event is to register an <em>event listener</em>
with the dispatcher. This listener can listen to one or more events and
is notified each time those events are dispatched.</p>
<p>Another way to listen to events is via an <em>event subscriber</em>. An event
subscriber is a PHP class that’s able to tell the dispatcher exactly which
events it should subscribe to. It implements the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/EventDispatcher/EventSubscriberInterface.php" title="Symfony\Component\EventDispatcher\EventSubscriberInterface"><span class="pre">EventSubscriberInterface</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/EventDispatcher/EventSubscriberInterface.php]</span></span></code>
interface, which requires a single static method called
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/EventDispatcher/EventSubscriberInterface.php" title="Symfony\Component\EventDispatcher\EventSubscriberInterface::getSubscribedEvents()"><span class="pre">getSubscribedEvents()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/EventDispatcher/EventSubscriberInterface.php]</span></span></code>.
Take the following example of a subscriber that subscribes to the
<code class="docutils literal notranslate"><span class="pre">kernel.response</span></code> and <code class="docutils literal notranslate"><span class="pre">order.placed</span></code> events:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="nx">Acme\Store\Event</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Acme\Store\Event\OrderPlacedEvent</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\EventDispatcher\EventSubscriberInterface</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpKernel\Event\ResponseEvent</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\HttpKernel\KernelEvents</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">StoreSubscriber</span> <span class="k">implements</span> <span class="nx">EventSubscriberInterface</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getSubscribedEvents</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="nx">KernelEvents</span><span class="o">::</span><span class="na">RESPONSE</span> <span class="o">=&gt;</span> <span class="p">[</span>
                <span class="p">[</span><span class="s1">&#39;onKernelResponsePre&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                <span class="p">[</span><span class="s1">&#39;onKernelResponsePost&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span>
            <span class="p">],</span>
            <span class="nx">OrderPlacedEvent</span><span class="o">::</span><span class="na">NAME</span> <span class="o">=&gt;</span> <span class="s1">&#39;onStoreOrder&#39;</span><span class="p">,</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">onKernelResponsePre</span><span class="p">(</span><span class="nx">ResponseEvent</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">onKernelResponsePost</span><span class="p">(</span><span class="nx">ResponseEvent</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">onStoreOrder</span><span class="p">(</span><span class="nx">OrderPlacedEvent</span> <span class="nv">$event</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is very similar to a listener class, except that the class itself can
tell the dispatcher which events it should listen to. To register a subscriber
with the dispatcher, use the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/EventDispatcher/EventDispatcher.php" title="Symfony\Component\EventDispatcher\EventDispatcher::addSubscriber()"><span class="pre">addSubscriber()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/EventDispatcher/EventDispatcher.php]</span></span></code>
method:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Acme\Store\Event\StoreSubscriber</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="nv">$subscriber</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StoreSubscriber</span><span class="p">();</span>
<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">addSubscriber</span><span class="p">(</span><span class="nv">$subscriber</span><span class="p">);</span>
</pre></div>
</div>
<p>The dispatcher will automatically register the subscriber for each event
returned by the <code class="docutils literal notranslate"><span class="pre">getSubscribedEvents()</span></code> method. This method returns an array
indexed by event names and whose values are either the method name to call
or an array composed of the method name to call and a priority (a positive or
negative integer that defaults to <code class="docutils literal notranslate"><span class="pre">0</span></code>).</p>
<p>The example above shows how to register several listener methods for the same
event in subscriber and also shows how to pass the priority of each listener
method. The higher the number, the earlier the method is called. In the above
example, when the <code class="docutils literal notranslate"><span class="pre">kernel.response</span></code> event is triggered, the methods
<code class="docutils literal notranslate"><span class="pre">onKernelResponsePre()</span></code> and <code class="docutils literal notranslate"><span class="pre">onKernelResponsePost()</span></code> are called in that
order.</p>
</div>
<div class="section" id="stopping-event-flow-propagation">
<span id="event-dispatcher-event-propagation"></span><span id="index-7"></span><h3>Stopping Event Flow/Propagation</h3>
<p>In some cases, it may make sense for a listener to prevent any other listeners
from being called. In other words, the listener needs to be able to tell
the dispatcher to stop all propagation of the event to future listeners
(i.e. to not notify any more listeners). This can be accomplished from
inside a listener via the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/EventDispatcher/Event.php" title="Symfony\Contracts\EventDispatcher\Event::stopPropagation()"><span class="pre">stopPropagation()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/EventDispatcher/Event.php]</span></span></code> method:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Acme\Store\Event\OrderPlacedEvent</span><span class="p">;</span>

<span class="k">public</span> <span class="k">function</span> <span class="nf">onStoreOrder</span><span class="p">(</span><span class="nx">OrderPlacedEvent</span> <span class="nv">$event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>

    <span class="nv">$event</span><span class="o">-&gt;</span><span class="na">stopPropagation</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, any listeners to <code class="docutils literal notranslate"><span class="pre">order.placed</span></code> that have not yet been called will
<em>not</em> be called.</p>
<p>It is possible to detect if an event was stopped by using the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/EventDispatcher/Event.php" title="Symfony\Contracts\EventDispatcher\Event::isPropagationStopped()"><span class="pre">isPropagationStopped()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/EventDispatcher/Event.php]</span></span></code>
method which returns a boolean value:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$dispatcher</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="nv">$event</span><span class="p">,</span> <span class="s1">&#39;foo.event&#39;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nv">$event</span><span class="o">-&gt;</span><span class="na">isPropagationStopped</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="eventdispatcher-aware-events-and-listeners">
<span id="event-dispatcher-dispatcher-aware-events"></span><span id="index-8"></span><h3>EventDispatcher Aware Events and Listeners</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">EventDispatcher</span></code> always passes the dispatched event, the event’s
name and a reference to itself to the listeners. This can lead to some advanced
applications of the <code class="docutils literal notranslate"><span class="pre">EventDispatcher</span></code> including dispatching other events inside
listeners, chaining events or even lazy loading listeners into the dispatcher object.</p>
</div>
<div class="section" id="event-name-introspection">
<span id="event-dispatcher-event-name-introspection"></span><span id="index-9"></span><h3>Event Name Introspection</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">EventDispatcher</span></code> instance, as well as the name of the event that
is dispatched, are passed as arguments to the listener:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Contracts\EventDispatcher\Event</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Contracts\EventDispatcher\EventDispatcherInterface</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">myEventListener</span><span class="p">(</span><span class="nx">Event</span> <span class="nv">$event</span><span class="p">,</span> <span class="nv">$eventName</span><span class="p">,</span> <span class="nx">EventDispatcherInterface</span> <span class="nv">$dispatcher</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ... do something with the event name</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="other-dispatchers">
<h2>Other Dispatchers</h2>
<p>Besides the commonly used <code class="docutils literal notranslate"><span class="pre">EventDispatcher</span></code>, the component comes
with some other dispatchers:</p>
<ul class="simple">
<li><p><a class="reference internal" href="event_dispatcher/immutable_dispatcher.xhtml"><span class="doc">The Immutable Event Dispatcher</span></a></p></li>
<li><p><a class="reference internal" href="event_dispatcher/traceable_dispatcher.xhtml"><span class="doc">The Traceable Event Dispatcher</span></a></p></li>
</ul>
</div>
<div class="section" id="learn-more">
<h2>Learn More</h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher/container_aware_dispatcher.xhtml">The Container Aware Event Dispatcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher/generic_event.xhtml">The Generic Event Object</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher/immutable_dispatcher.xhtml">The Immutable Event Dispatcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="event_dispatcher/traceable_dispatcher.xhtml">The Traceable Event Dispatcher</a></li>
<li class="toctree-l1"><a class="reference internal" href="../event_dispatcher/before_after_filters.xhtml">How to Set Up Before and After Filters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../event_dispatcher/method_behavior.xhtml">How to Customize a Method Behavior without Using Inheritance</a></li>
</ul>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="../reference/dic_tags.xhtml#dic-tags-kernel-event-listener"><span class="std std-ref">The kernel.event_listener tag</span></a></p></li>
<li><p><a class="reference internal" href="../reference/dic_tags.xhtml#dic-tags-kernel-event-subscriber"><span class="std std-ref">The kernel.event_subscriber tag</span></a></p></li>
</ul>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>