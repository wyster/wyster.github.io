<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>The Cache Component</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-cache-component">
<span id="cache-component"></span><span id="index-0"></span><h1>The Cache Component</h1>
<blockquote>
<div><p>The Cache component provides features covering simple to advanced caching needs.
It natively implements <a class="reference external" href="https://www.php-fig.org/psr/psr-6/">PSR-6</a><span class="link-target"> [https://www.php-fig.org/psr/psr-6/]</span> and the <a class="reference external" href="https://github.com/symfony/contracts/blob/master/Cache/CacheInterface.php">Cache Contracts</a><span class="link-target"> [https://github.com/symfony/contracts/blob/master/Cache/CacheInterface.php]</span> for greatest
interoperability. It is designed for performance and resiliency, ships with
ready to use adapters for the most common caching backends. It enables tag-based
invalidation and cache stampede protection via locking and early expiration.</p>
</div></blockquote>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The component also contains adapters to convert between PSR-6, PSR-16 and
Doctrine caches. See <a class="reference internal" href="cache/psr6_psr16_adapters.xhtml"><span class="doc">Adapters For Interoperability between PSR-6 and PSR-16 Cache</span></a> and
<a class="reference internal" href="cache/adapters/doctrine_adapter.xhtml"><span class="doc">Doctrine Cache Adapter</span></a>.</p>
</div>
<div class="section" id="installation">
<h2>Installation</h2>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> composer require symfony/cache
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you install this component outside of a Symfony application, you must
require the <code class="docutils literal notranslate"><span class="pre">vendor/autoload.php</span></code> file in your code to enable the class
autoloading mechanism provided by Composer. Read
<a class="reference internal" href="using_components.xhtml"><span class="doc">this article</span></a> for more details.</p>
</div>
</div>
<div class="section" id="cache-contracts-versus-psr-6">
<h2>Cache Contracts versus PSR-6</h2>
<p>This component includes <em>two</em> different approaches to caching:</p>
<dl class="simple">
<dt><a class="reference internal" href="#cache-component-psr6-caching"><span class="std std-ref">PSR-6 Caching</span></a>:</dt>
<dd><p>A generic cache system, which involves cache “pools” and cache “items”.</p>
</dd>
<dt><a class="reference internal" href="#cache-component-contracts"><span class="std std-ref">Cache Contracts</span></a>:</dt>
<dd><p>A simpler yet more powerful way to cache values based on recomputation callbacks.</p>
</dd>
</dl>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Using the Cache Contracts approach is recommended: it requires less
code boilerplate and provides cache stampede protection by default.</p>
</div>
</div>
<div class="section" id="cache-contracts">
<span id="cache-component-contracts"></span><h2>Cache Contracts</h2>
<p>All adapters support the Cache Contracts. They contain only two methods:
<code class="docutils literal notranslate"><span class="pre">get()</span></code> and <code class="docutils literal notranslate"><span class="pre">delete()</span></code>. There’s no <code class="docutils literal notranslate"><span class="pre">set()</span></code> method because the <code class="docutils literal notranslate"><span class="pre">get()</span></code>
method both gets and sets the cache values.</p>
<p>The first thing you need is to instantiate a cache adapter. The
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/Adapter/FilesystemAdapter.php" title="Symfony\Component\Cache\Adapter\FilesystemAdapter"><span class="pre">FilesystemAdapter</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/Adapter/FilesystemAdapter.php]</span></span></code> is used in this
example:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\FilesystemAdapter</span><span class="p">;</span>

<span class="nv">$cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FilesystemAdapter</span><span class="p">();</span>
</pre></div>
</div>
<p>Now you can retrieve and delete cached data using this object. The first
argument of the <code class="docutils literal notranslate"><span class="pre">get()</span></code> method is a key, an arbitrary string that you
associate to the cached value so you can retrieve it later. The second argument
is a PHP callable which is executed when the key is not found in the cache to
generate and return the value:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Contracts\Cache\ItemInterface</span><span class="p">;</span>

<span class="c1">// The callable will only be executed on a cache miss.</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;my_cache_key&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">ItemInterface</span> <span class="nv">$item</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$item</span><span class="o">-&gt;</span><span class="na">expiresAfter</span><span class="p">(</span><span class="mi">3600</span><span class="p">);</span>

    <span class="c1">// ... do some HTTP request or heavy computations</span>
    <span class="nv">$computedValue</span> <span class="o">=</span> <span class="s1">&#39;foobar&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="nv">$computedValue</span><span class="p">;</span>
<span class="p">});</span>

<span class="k">echo</span> <span class="nv">$value</span><span class="p">;</span> <span class="c1">// &#39;foobar&#39;</span>

<span class="c1">// ... and to remove the cache key</span>
<span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">delete</span><span class="p">(</span><span class="s1">&#39;my_cache_key&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use cache tags to delete more than one key at the time. Read more at
<a class="reference internal" href="cache/cache_invalidation.xhtml"><span class="doc">Cache Invalidation</span></a>.</p>
</div>
<p>The Cache Contracts also comes with built in <a class="reference external" href="https://en.wikipedia.org/wiki/Cache_stampede">Stampede prevention</a><span class="link-target"> [https://en.wikipedia.org/wiki/Cache_stampede]</span>. This will
remove CPU spikes at the moments when the cache is cold. If an example application
spends 5 seconds to compute data that is cached for 1 hour and this data is accessed
10 times every second, this means that you mostly have cache hits and everything
is fine. But after 1 hour, we get 10 new requests to a cold cache. So the data
is computed again. The next second the same thing happens. So the data is computed
about 50 times before the cache is warm again. This is where you need stampede
prevention.</p>
<p>The first solution is to use locking: only allow one PHP process (on a per-host basis)
to compute a specific key at a time. Locking is built-in by default, so
you don’t need to do anything beyond leveraging the Cache Contracts.</p>
<p>The second solution is also built-in when using the Cache Contracts: instead of
waiting for the full delay before expiring a value, recompute it ahead of its
expiration date. The <a class="reference external" href="https://en.wikipedia.org/wiki/Cache_stampede#Probabilistic_early_expiration">Probabilistic early expiration</a><span class="link-target"> [https://en.wikipedia.org/wiki/Cache_stampede#Probabilistic_early_expiration]</span> algorithm randomly fakes a
cache miss for one user while others are still served the cached value. You can
control its behavior with the third optional parameter of
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/CacheInterface.php" title="Symfony\Contracts\Cache\CacheInterface::get()"><span class="pre">get()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/CacheInterface.php]</span></span></code>,
which is a float value called “beta”.</p>
<p>By default the beta is <code class="docutils literal notranslate"><span class="pre">1.0</span></code> and higher values mean earlier recompute. Set it
to <code class="docutils literal notranslate"><span class="pre">0</span></code> to disable early recompute and set it to <code class="docutils literal notranslate"><span class="pre">INF</span></code> to force an immediate
recompute:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Contracts\Cache\ItemInterface</span><span class="p">;</span>

<span class="nv">$beta</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;my_cache_key&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">ItemInterface</span> <span class="nv">$item</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$item</span><span class="o">-&gt;</span><span class="na">expiresAfter</span><span class="p">(</span><span class="mi">3600</span><span class="p">);</span>
    <span class="nv">$item</span><span class="o">-&gt;</span><span class="na">tag</span><span class="p">([</span><span class="s1">&#39;tag_0&#39;</span><span class="p">,</span> <span class="s1">&#39;tag_1&#39;</span><span class="p">]);</span>

    <span class="k">return</span> <span class="s1">&#39;...&#39;</span><span class="p">;</span>
<span class="p">},</span> <span class="nv">$beta</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="available-cache-adapters">
<h3>Available Cache Adapters</h3>
<p>The following cache adapters are available:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/apcu_adapter.xhtml">APCu Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/array_cache_adapter.xhtml">Array Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/chain_adapter.xhtml">Chain Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/doctrine_adapter.xhtml">Doctrine Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/filesystem_adapter.xhtml">Filesystem Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/memcached_adapter.xhtml">Memcached Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/pdo_doctrine_dbal_adapter.xhtml">PDO &amp; Doctrine DBAL Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/php_array_cache_adapter.xhtml">PHP Array Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/php_files_adapter.xhtml">PHP Files Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/proxy_adapter.xhtml">Proxy Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/adapters/redis_adapter.xhtml">Redis Cache Adapter</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="generic-caching-psr-6">
<span id="cache-component-psr6-caching"></span><h2>Generic Caching (PSR-6)</h2>
<p>To use the generic PSR-6 Caching abilities, you’ll need to learn its key
concepts:</p>
<dl class="simple">
<dt><strong>Item</strong></dt>
<dd><p>A single unit of information stored as a key/value pair, where the key is
the unique identifier of the information and the value is its contents;
see the <a class="reference internal" href="cache/cache_items.xhtml"><span class="doc">Cache Items</span></a> article for more details.</p>
</dd>
<dt><strong>Pool</strong></dt>
<dd><p>A logical repository of cache items. All cache operations (saving items,
looking for items, etc.) are performed through the pool. Applications can
define as many pools as needed.</p>
</dd>
<dt><strong>Adapter</strong></dt>
<dd><p>It implements the actual caching mechanism to store the information in the
filesystem, in a database, etc. The component provides several ready to use
adapters for common caching backends (Redis, APCu, Doctrine, PDO, etc.)</p>
</dd>
</dl>
</div>
<div class="section" id="basic-usage-psr-6">
<h2>Basic Usage (PSR-6)</h2>
<p>This part of the component is an implementation of <a class="reference external" href="https://www.php-fig.org/psr/psr-6/">PSR-6</a><span class="link-target"> [https://www.php-fig.org/psr/psr-6/]</span>, which means that its
basic API is the same as defined in the document. Before starting to cache information,
create the cache pool using any of the built-in adapters. For example, to create
a filesystem-based cache, instantiate <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/Adapter/FilesystemAdapter.php" title="Symfony\Component\Cache\Adapter\FilesystemAdapter"><span class="pre">FilesystemAdapter</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/Adapter/FilesystemAdapter.php]</span></span></code>:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\FilesystemAdapter</span><span class="p">;</span>

<span class="nv">$cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FilesystemAdapter</span><span class="p">();</span>
</pre></div>
</div>
<p>Now you can create, retrieve, update and delete items using this cache pool:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a new item by trying to get it from the cache</span>
<span class="nv">$productsCount</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">getItem</span><span class="p">(</span><span class="s1">&#39;stats.products_count&#39;</span><span class="p">);</span>

<span class="c1">// assign a value to the item and save it</span>
<span class="nv">$productsCount</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="mi">4711</span><span class="p">);</span>
<span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">save</span><span class="p">(</span><span class="nv">$productsCount</span><span class="p">);</span>

<span class="c1">// retrieve the cache item</span>
<span class="nv">$productsCount</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">getItem</span><span class="p">(</span><span class="s1">&#39;stats.products_count&#39;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$productsCount</span><span class="o">-&gt;</span><span class="na">isHit</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// ... item does not exist in the cache</span>
<span class="p">}</span>
<span class="c1">// retrieve the value stored by the item</span>
<span class="nv">$total</span> <span class="o">=</span> <span class="nv">$productsCount</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">();</span>

<span class="c1">// remove the cache item</span>
<span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">deleteItem</span><span class="p">(</span><span class="s1">&#39;stats.products_count&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>For a list of all of the supported adapters, see <a class="reference internal" href="cache/cache_pools.xhtml"><span class="doc">Cache Pools and Supported Adapters</span></a>.</p>
</div>
<div class="section" id="advanced-usage">
<h2>Advanced Usage</h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="cache/cache_invalidation.xhtml">Cache Invalidation</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/cache_items.xhtml">Cache Items</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/cache_pools.xhtml">Cache Pools and Supported Adapters</a></li>
<li class="toctree-l1"><a class="reference internal" href="cache/psr6_psr16_adapters.xhtml">Adapters For Interoperability between PSR-6 and PSR-16 Cache</a></li>
</ul>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>