<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>Cache Pools and Supported Adapters</title>
    <link rel="stylesheet" href="../../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="cache-pools-and-supported-adapters">
<span id="component-cache-cache-pools"></span><span id="index-0"></span><h1>Cache Pools and Supported Adapters</h1>
<p>Cache Pools are the logical repositories of cache items. They perform all the
common operations on items, such as saving them or looking for them. Cache pools
are independent of the actual cache implementation. Therefore, applications
can keep using the same cache pool even if the underlying cache mechanism
changes from a file system based cache to a Redis or database based cache.</p>
<div class="section" id="creating-cache-pools">
<span id="component-cache-creating-cache-pools"></span><h2>Creating Cache Pools</h2>
<p>Cache Pools are created through the <strong>cache adapters</strong>, which are classes that
implement both <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/CacheInterface.php" title="Symfony\Contracts\Cache\CacheInterface"><span class="pre">CacheInterface</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/CacheInterface.php]</span></span></code> and
<code class="docutils literal notranslate"><span class="pre">Psr\Cache\CacheItemPoolInterface</span></code>. This component provides several adapters
ready to use in your applications.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="adapters/apcu_adapter.xhtml">APCu Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/array_cache_adapter.xhtml">Array Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/chain_adapter.xhtml">Chain Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/couchbasebucket_adapter.xhtml">Couchbase Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/doctrine_adapter.xhtml">Doctrine Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/filesystem_adapter.xhtml">Filesystem Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/memcached_adapter.xhtml">Memcached Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/pdo_doctrine_dbal_adapter.xhtml">PDO &amp; Doctrine DBAL Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/php_array_cache_adapter.xhtml">PHP Array Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/php_files_adapter.xhtml">PHP Files Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/proxy_adapter.xhtml">Proxy Cache Adapter</a></li>
<li class="toctree-l1"><a class="reference internal" href="adapters/redis_adapter.xhtml">Redis Cache Adapter</a></li>
</ul>
</div>
</div>
<div class="section" id="using-the-cache-contracts">
<h2>Using the Cache Contracts</h2>
<p>The <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/CacheInterface.php" title="Symfony\Contracts\Cache\CacheInterface"><span class="pre">CacheInterface</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/CacheInterface.php]</span></span></code> allows fetching, storing
and deleting cache items using only two methods and a callback:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\FilesystemAdapter</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Contracts\Cache\ItemInterface</span><span class="p">;</span>

<span class="nv">$cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FilesystemAdapter</span><span class="p">();</span>

<span class="c1">// The callable will only be executed on a cache miss.</span>
<span class="nv">$value</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">(</span><span class="s1">&#39;my_cache_key&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">ItemInterface</span> <span class="nv">$item</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$item</span><span class="o">-&gt;</span><span class="na">expiresAfter</span><span class="p">(</span><span class="mi">3600</span><span class="p">);</span>

    <span class="c1">// ... do some HTTP request or heavy computations</span>
    <span class="nv">$computedValue</span> <span class="o">=</span> <span class="s1">&#39;foobar&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="nv">$computedValue</span><span class="p">;</span>
<span class="p">});</span>

<span class="k">echo</span> <span class="nv">$value</span><span class="p">;</span> <span class="c1">// &#39;foobar&#39;</span>

<span class="c1">// ... and to remove the cache key</span>
<span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">delete</span><span class="p">(</span><span class="s1">&#39;my_cache_key&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Out of the box, using this interface provides stampede protection via locking
and early expiration. Early expiration can be controlled via the third “beta”
argument of the <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/CacheInterface.php" title="Symfony\Contracts\Cache\CacheInterface::get()"><span class="pre">get()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/CacheInterface.php]</span></span></code> method.
See the <a class="reference internal" href="../cache.xhtml"><span class="doc">The Cache Component</span></a> article for more information.</p>
<p>Early expiration can be detected inside the callback by calling the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/ItemInterface.php" title="Symfony\Contracts\Cache\ItemInterface::isHit()"><span class="pre">isHit()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Contracts/Cache/ItemInterface.php]</span></span></code> method: if this
returns <code class="docutils literal notranslate"><span class="pre">true</span></code>, it means we are currently recomputing a value ahead of its
expiration date.</p>
<p>For advanced use cases, the callback can accept a second <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">&amp;$save</span></code>
argument passed by reference. By setting <code class="docutils literal notranslate"><span class="pre">$save</span></code> to <code class="docutils literal notranslate"><span class="pre">false</span></code> inside the
callback, you can instruct the cache pool that the returned value <em>should not</em>
be stored in the backend.</p>
</div>
<div class="section" id="using-psr-6">
<h2>Using PSR-6</h2>
<div class="section" id="looking-for-cache-items">
<h3>Looking for Cache Items</h3>
<p>Cache Pools define three methods to look for cache items. The most common method
is <code class="docutils literal notranslate"><span class="pre">getItem($key)</span></code>, which returns the cache item identified by the given key:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\FilesystemAdapter</span><span class="p">;</span>

<span class="nv">$cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FilesystemAdapter</span><span class="p">(</span><span class="s1">&#39;app.cache&#39;</span><span class="p">);</span>
<span class="nv">$latestNews</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">getItem</span><span class="p">(</span><span class="s1">&#39;latest_news&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>If no item is defined for the given key, the method doesn’t return a <code class="docutils literal notranslate"><span class="pre">null</span></code>
value but an empty object which implements the <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/CacheItem.php" title="Symfony\Component\Cache\CacheItem"><span class="pre">CacheItem</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/CacheItem.php]</span></span></code>
class.</p>
<p>If you need to fetch several cache items simultaneously, use instead the
<code class="docutils literal notranslate"><span class="pre">getItems([$key1,</span> <span class="pre">$key2,</span> <span class="pre">...])</span></code> method:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$stocks</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">getItems</span><span class="p">([</span><span class="s1">&#39;AAPL&#39;</span><span class="p">,</span> <span class="s1">&#39;FB&#39;</span><span class="p">,</span> <span class="s1">&#39;GOOGL&#39;</span><span class="p">,</span> <span class="s1">&#39;MSFT&#39;</span><span class="p">]);</span>
</pre></div>
</div>
<p>Again, if any of the keys doesn’t represent a valid cache item, you won’t get
a <code class="docutils literal notranslate"><span class="pre">null</span></code> value but an empty <code class="docutils literal notranslate"><span class="pre">CacheItem</span></code> object.</p>
<p>The last method related to fetching cache items is <code class="docutils literal notranslate"><span class="pre">hasItem($key)</span></code>, which
returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if there is a cache item identified by the given key:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$hasBadges</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">hasItem</span><span class="p">(</span><span class="s1">&#39;user_&#39;</span><span class="o">.</span><span class="nv">$userId</span><span class="o">.</span><span class="s1">&#39;_badges&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="saving-cache-items">
<h3>Saving Cache Items</h3>
<p>The most common method to save cache items is
<code class="docutils literal notranslate"><span class="pre">Psr\Cache\CacheItemPoolInterface::save</span></code>, which stores the
item in the cache immediately (it returns <code class="docutils literal notranslate"><span class="pre">true</span></code> if the item was saved or
<code class="docutils literal notranslate"><span class="pre">false</span></code> if some error occurred):</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$userFriends</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">getItem</span><span class="p">(</span><span class="s1">&#39;user_&#39;</span><span class="o">.</span><span class="nv">$userId</span><span class="o">.</span><span class="s1">&#39;_friends&#39;</span><span class="p">);</span>
<span class="nv">$userFriends</span><span class="o">-&gt;</span><span class="na">set</span><span class="p">(</span><span class="nv">$user</span><span class="o">-&gt;</span><span class="na">getFriends</span><span class="p">());</span>
<span class="nv">$isSaved</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">save</span><span class="p">(</span><span class="nv">$userFriends</span><span class="p">);</span>
</pre></div>
</div>
<p>Sometimes you may prefer to not save the objects immediately in order to
increase the application performance. In those cases, use the
<code class="docutils literal notranslate"><span class="pre">Psr\Cache\CacheItemPoolInterface::saveDeferred</span></code> method to mark cache
items as “ready to be persisted” and then call to
<code class="docutils literal notranslate"><span class="pre">Psr\Cache\CacheItemPoolInterface::commit</span></code> method when you are ready
to persist them all:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$isQueued</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">saveDeferred</span><span class="p">(</span><span class="nv">$userFriends</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="nv">$isQueued</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">saveDeferred</span><span class="p">(</span><span class="nv">$userPreferences</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="nv">$isQueued</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">saveDeferred</span><span class="p">(</span><span class="nv">$userRecentProducts</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="nv">$isSaved</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">commit</span><span class="p">();</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">saveDeferred()</span></code> method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> when the cache item has been
successfully added to the “persist queue” and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise. The <code class="docutils literal notranslate"><span class="pre">commit()</span></code>
method returns <code class="docutils literal notranslate"><span class="pre">true</span></code> when all the pending items are successfully saved or
<code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise.</p>
</div>
<div class="section" id="removing-cache-items">
<h3>Removing Cache Items</h3>
<p>Cache Pools include methods to delete a cache item, some of them or all of them.
The most common is <code class="docutils literal notranslate"><span class="pre">Psr\Cache\CacheItemPoolInterface::deleteItem</span></code>,
which deletes the cache item identified by the given key (it returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
when the item is successfully deleted or doesn’t exist and <code class="docutils literal notranslate"><span class="pre">false</span></code> otherwise):</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$isDeleted</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">deleteItem</span><span class="p">(</span><span class="s1">&#39;user_&#39;</span><span class="o">.</span><span class="nv">$userId</span><span class="p">);</span>
</pre></div>
</div>
<p>Use the <code class="docutils literal notranslate"><span class="pre">Psr\Cache\CacheItemPoolInterface::deleteItems</span></code> method to
delete several cache items simultaneously (it returns <code class="docutils literal notranslate"><span class="pre">true</span></code> only if all the
items have been deleted, even when any or some of them don’t exist):</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$areDeleted</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">deleteItems</span><span class="p">([</span><span class="s1">&#39;category1&#39;</span><span class="p">,</span> <span class="s1">&#39;category2&#39;</span><span class="p">]);</span>
</pre></div>
</div>
<p>Finally, to remove all the cache items stored in the pool, use the
<code class="docutils literal notranslate"><span class="pre">Psr\Cache\CacheItemPoolInterface::clear</span></code> method (which returns <code class="docutils literal notranslate"><span class="pre">true</span></code>
when all items are successfully deleted):</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$cacheIsEmpty</span> <span class="o">=</span> <span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">clear</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If the cache component is used inside a Symfony application, you can remove
items from cache pools using the following commands (which reside within
the <a class="reference internal" href="../../reference/configuration/framework.xhtml#framework-bundle-configuration"><span class="std std-ref">framework bundle</span></a>):</p>
<p>To remove <em>one specific item</em> from the <em>given pool</em>:</p>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> php bin/console cache:pool:delete &lt;cache-pool-name&gt; &lt;cache-key-name&gt;

<span class="c1"># deletes the &quot;cache_key&quot; item from the &quot;cache.app&quot; pool</span>
<span class="gp">$</span> php bin/console cache:pool:delete cache.app cache_key
</pre></div>
</td></tr></table></div>
<p>You can also remove <em>all items</em> from the <em>given pool(s)</em>:</p>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> php bin/console cache:pool:clear &lt;cache-pool-name&gt;

<span class="c1"># clears the &quot;cache.app&quot; pool</span>
<span class="gp">$</span> php bin/console cache:pool:clear cache.app

<span class="c1"># clears the &quot;cache.validation&quot; and &quot;cache.app&quot; pool</span>
<span class="gp">$</span> php bin/console cache:pool:clear cache.validation cache.app
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>
<div class="section" id="pruning-cache-items">
<span id="component-cache-cache-pool-prune"></span><h2>Pruning Cache Items</h2>
<p>Some cache pools do not include an automated mechanism for pruning expired cache items.
For example, the <a class="reference internal" href="adapters/filesystem_adapter.xhtml#component-cache-filesystem-adapter"><span class="std std-ref">FilesystemAdapter</span></a> cache
does not remove expired cache items <em>until an item is explicitly requested and determined to
be expired</em>, for example, via a call to <code class="docutils literal notranslate"><span class="pre">Psr\Cache\CacheItemPoolInterface::getItem</span></code>.
Under certain workloads, this can cause stale cache entries to persist well past their
expiration, resulting in a sizable consumption of wasted disk or memory space from excess,
expired cache items.</p>
<p>This shortcoming has been solved through the introduction of
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/PruneableInterface.php" title="Symfony\Component\Cache\PruneableInterface"><span class="pre">PruneableInterface</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/PruneableInterface.php]</span></span></code>, which defines the abstract method
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/PruneableInterface.php" title="Symfony\Component\Cache\PruneableInterface::prune()"><span class="pre">prune()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/PruneableInterface.php]</span></span></code>. The
<a class="reference internal" href="adapters/chain_adapter.xhtml#component-cache-chain-adapter"><span class="std std-ref">ChainAdapter</span></a>,
<a class="reference internal" href="adapters/filesystem_adapter.xhtml#component-cache-filesystem-adapter"><span class="std std-ref">FilesystemAdapter</span></a>,
<a class="reference internal" href="adapters/pdo_doctrine_dbal_adapter.xhtml#pdo-doctrine-adapter"><span class="std std-ref">PdoAdapter</span></a>, and
<a class="reference internal" href="adapters/php_files_adapter.xhtml#component-cache-files-adapter"><span class="std std-ref">PhpFilesAdapter</span></a> all implement this new interface,
allowing manual removal of stale cache items:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\FilesystemAdapter</span><span class="p">;</span>

<span class="nv">$cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FilesystemAdapter</span><span class="p">(</span><span class="s1">&#39;app.cache&#39;</span><span class="p">);</span>
<span class="c1">// ... do some set and get operations</span>
<span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">prune</span><span class="p">();</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="adapters/chain_adapter.xhtml#component-cache-chain-adapter"><span class="std std-ref">ChainAdapter</span></a> implementation does not directly
contain any pruning logic itself. Instead, when calling the chain adapter’s
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/Adapter/ChainAdapter.php" title="Symfony\Component\Cache\Adapter\ChainAdapter::prune()"><span class="pre">prune()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/Adapter/ChainAdapter.php]</span></span></code> method, the call is delegated to all
its compatible cache adapters (and those that do not implement <code class="docutils literal notranslate"><span class="pre">PruneableInterface</span></code> are
silently ignored):</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\ApcuAdapter</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\ChainAdapter</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\FilesystemAdapter</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\PdoAdapter</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Cache\Adapter\PhpFilesAdapter</span><span class="p">;</span>

<span class="nv">$cache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ChainAdapter</span><span class="p">([</span>
    <span class="k">new</span> <span class="nx">ApcuAdapter</span><span class="p">(),</span>       <span class="c1">// does NOT implement PruneableInterface</span>
    <span class="k">new</span> <span class="nx">FilesystemAdapter</span><span class="p">(),</span> <span class="c1">// DOES implement PruneableInterface</span>
    <span class="k">new</span> <span class="nx">PdoAdapter</span><span class="p">(),</span>        <span class="c1">// DOES implement PruneableInterface</span>
    <span class="k">new</span> <span class="nx">PhpFilesAdapter</span><span class="p">(),</span>   <span class="c1">// DOES implement PruneableInterface</span>
    <span class="c1">// ...</span>
<span class="p">]);</span>

<span class="c1">// prune will proxy the call to PdoAdapter, FilesystemAdapter and PhpFilesAdapter,</span>
<span class="c1">// while silently skipping ApcuAdapter</span>
<span class="nv">$cache</span><span class="o">-&gt;</span><span class="na">prune</span><span class="p">();</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If the cache component is used inside a Symfony application, you can prune
<em>all items</em> from <em>all pools</em> using the following command (which resides within
the <a class="reference internal" href="../../reference/configuration/framework.xhtml#framework-bundle-configuration"><span class="std std-ref">framework bundle</span></a>):</p>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> php bin/console cache:pool:prune
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>