<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>The Lock Component</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-lock-component">
<span id="index-0"></span><h1>The Lock Component</h1>
<blockquote>
<div><p>The Lock Component creates and manages <a class="reference external" href="https://en.wikipedia.org/wiki/Lock_(computer_science)">locks</a><span class="link-target"> [https://en.wikipedia.org/wiki/Lock_(computer_science)]</span>, a mechanism to provide
exclusive access to a shared resource.</p>
</div></blockquote>
<p>If you’re using the Symfony Framework, read the
<a class="reference internal" href="../lock.xhtml"><span class="doc">Symfony Framework Lock documentation</span></a>.</p>
<div class="section" id="installation">
<h2>Installation</h2>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> composer require symfony/lock
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you install this component outside of a Symfony application, you must
require the <code class="docutils literal notranslate"><span class="pre">vendor/autoload.php</span></code> file in your code to enable the class
autoloading mechanism provided by Composer. Read
<a class="reference internal" href="using_components.xhtml"><span class="doc">this article</span></a> for more details.</p>
</div>
</div>
<div class="section" id="usage">
<h2>Usage</h2>
<p>Locks are used to guarantee exclusive access to some shared resource. In
Symfony applications, you can use locks for example to ensure that a command is
not executed more than once at the same time (on the same or different servers).</p>
<p>Locks are created using a <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/LockFactory.php" title="Symfony\Component\Lock\LockFactory"><span class="pre">LockFactory</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/LockFactory.php]</span></span></code> class,
which in turn requires another class to manage the storage of locks:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\LockFactory</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\SemaphoreStore</span><span class="p">;</span>

<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SemaphoreStore</span><span class="p">();</span>
<span class="nv">$factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LockFactory</span><span class="p">(</span><span class="nv">$store</span><span class="p">);</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.4: </span>The <code class="docutils literal notranslate"><span class="pre">Symfony\Component\Lock\LockFactory</span></code> class was introduced in Symfony
4.4. In previous versions it was called <code class="docutils literal notranslate"><span class="pre">Symfony\Component\Lock\Factory</span></code>.</p>
</div>
<p>The lock is created by calling the <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/LockFactory.php" title="Symfony\Component\Lock\LockFactory::createLock()"><span class="pre">createLock()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/LockFactory.php]</span></span></code>
method. Its first argument is an arbitrary string that represents the locked
resource. Then, a call to the <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/LockInterface.php" title="Symfony\Component\Lock\LockInterface::acquire()"><span class="pre">acquire()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/LockInterface.php]</span></span></code>
method will try to acquire the lock:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$lock</span> <span class="o">=</span> <span class="nv">$factory</span><span class="o">-&gt;</span><span class="na">createLock</span><span class="p">(</span><span class="s1">&#39;pdf-invoice-generation&#39;</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">acquire</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// The resource &quot;pdf-invoice-generation&quot; is locked.</span>
    <span class="c1">// You can compute and generate invoice safely here.</span>

    <span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">release</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the lock can not be acquired, the method returns <code class="docutils literal notranslate"><span class="pre">false</span></code>. The <code class="docutils literal notranslate"><span class="pre">acquire()</span></code>
method can be safely called repeatedly, even if the lock is already acquired.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike other implementations, the Lock Component distinguishes locks
instances even when they are created for the same resource. If a lock has
to be used by several services, they should share the same <code class="docutils literal notranslate"><span class="pre">Lock</span></code> instance
returned by the <code class="docutils literal notranslate"><span class="pre">LockFactory::createLock</span></code> method.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>If you don’t release the lock explicitly, it will be released automatically
on instance destruction. In some cases, it can be useful to lock a resource
across several requests. To disable the automatic release behavior, set the
third argument of the <code class="docutils literal notranslate"><span class="pre">createLock()</span></code> method to <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
</div>
<div class="section" id="serializing-locks">
<h2>Serializing Locks</h2>
<p>The <code class="docutils literal notranslate"><span class="pre">Key</span></code> contains the state of the <code class="docutils literal notranslate"><span class="pre">Lock</span></code> and can be serialized. This
allows the user to begin a long job in a process by acquiring the lock, and
continue the job in an other process using the same lock:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\Key</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Lock\Lock</span><span class="p">;</span>

<span class="nv">$key</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Key</span><span class="p">(</span><span class="s1">&#39;article.&#39;</span><span class="o">.</span><span class="nv">$article</span><span class="o">-&gt;</span><span class="na">getId</span><span class="p">());</span>
<span class="nv">$lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Lock</span><span class="p">(</span><span class="nv">$key</span><span class="p">,</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">store</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span>
<span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">acquire</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>

<span class="nv">$this</span><span class="o">-&gt;</span><span class="na">bus</span><span class="o">-&gt;</span><span class="na">dispatch</span><span class="p">(</span><span class="k">new</span> <span class="nx">RefreshTaxonomy</span><span class="p">(</span><span class="nv">$article</span><span class="p">,</span> <span class="nv">$key</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Don’t forget to disable the autoRelease to avoid releasing the lock when
the destructor is called.</p>
</div>
<p>Not all stores are compatible with serialization and cross-process locking:
for example, the kernel will automatically release semaphores acquired by the
<a class="reference internal" href="#lock-store-semaphore"><span class="std std-ref">SemaphoreStore</span></a> store. If you use an incompatible
store, an exception will be thrown when the application tries to serialize the key.</p>
</div>
<div class="section" id="blocking-locks">
<span id="lock-blocking-locks"></span><h2>Blocking Locks</h2>
<p>By default, when a lock cannot be acquired, the <code class="docutils literal notranslate"><span class="pre">acquire</span></code> method returns
<code class="docutils literal notranslate"><span class="pre">false</span></code> immediately. To wait (indefinitely) until the lock
can be created, pass <code class="docutils literal notranslate"><span class="pre">true</span></code> as the argument of the <code class="docutils literal notranslate"><span class="pre">acquire()</span></code> method. This
is called a <strong>blocking lock</strong> because the execution of your application stops
until the lock is acquired.</p>
<p>Some of the built-in <code class="docutils literal notranslate"><span class="pre">Store</span></code> classes support this feature. When they don’t,
they can be decorated with the <code class="docutils literal notranslate"><span class="pre">RetryTillSaveStore</span></code> class:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\LockFactory</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\RedisStore</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\RetryTillSaveStore</span><span class="p">;</span>

<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RedisStore</span><span class="p">(</span><span class="k">new</span> <span class="nx">\Predis\Client</span><span class="p">(</span><span class="s1">&#39;tcp://localhost:6379&#39;</span><span class="p">));</span>
<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RetryTillSaveStore</span><span class="p">(</span><span class="nv">$store</span><span class="p">);</span>
<span class="nv">$factory</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LockFactory</span><span class="p">(</span><span class="nv">$store</span><span class="p">);</span>

<span class="nv">$lock</span> <span class="o">=</span> <span class="nv">$factory</span><span class="o">-&gt;</span><span class="na">createLock</span><span class="p">(</span><span class="s1">&#39;notification-flush&#39;</span><span class="p">);</span>
<span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">acquire</span><span class="p">(</span><span class="k">true</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="expiring-locks">
<h2>Expiring Locks</h2>
<p>Locks created remotely are difficult to manage because there is no way for the
remote <code class="docutils literal notranslate"><span class="pre">Store</span></code> to know if the locker process is still alive. Due to bugs,
fatal errors or segmentation faults, it cannot be guaranteed that <code class="docutils literal notranslate"><span class="pre">release()</span></code>
method will be called, which would cause the resource to be locked infinitely.</p>
<p>The best solution in those cases is to create <strong>expiring locks</strong>, which are
released automatically after some amount of time has passed (called TTL for
<em>Time To Live</em>). This time, in seconds, is configured as the second argument of
the <code class="docutils literal notranslate"><span class="pre">createLock()</span></code> method. If needed, these locks can also be released early
with the <code class="docutils literal notranslate"><span class="pre">release()</span></code> method.</p>
<p>The trickiest part when working with expiring locks is choosing the right TTL.
If it’s too short, other processes could acquire the lock before finishing the
job; if it’s too long and the process crashes before calling the <code class="docutils literal notranslate"><span class="pre">release()</span></code>
method, the resource will stay locked until the timeout:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="c1">// create an expiring lock that lasts 30 seconds</span>
<span class="nv">$lock</span> <span class="o">=</span> <span class="nv">$factory</span><span class="o">-&gt;</span><span class="na">createLock</span><span class="p">(</span><span class="s1">&#39;charts-generation&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">acquire</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="c1">// perform a job during less than 30 seconds</span>
<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">release</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>To avoid letting the lock in a locking state, it’s recommended to wrap the
job in a try/catch/finally block to always try to release the expiring lock.</p>
</div>
<p>In case of long-running tasks, it’s better to start with a not too long TTL and
then use the <code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/LockInterface.php" title="Symfony\Component\Lock\LockInterface::refresh()"><span class="pre">refresh()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/LockInterface.php]</span></span></code> method
to reset the TTL to its original value:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$lock</span> <span class="o">=</span> <span class="nv">$factory</span><span class="o">-&gt;</span><span class="na">createLock</span><span class="p">(</span><span class="s1">&#39;charts-generation&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">acquire</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nv">$finished</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// perform a small part of the job.</span>

        <span class="c1">// renew the lock for 30 more seconds.</span>
        <span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">refresh</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
    <span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">release</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Another useful technique for long-running tasks is to pass a custom TTL as
an argument of the <code class="docutils literal notranslate"><span class="pre">refresh()</span></code> method to change the default lock TTL:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="nv">$lock</span> <span class="o">=</span> <span class="nv">$factory</span><span class="o">-&gt;</span><span class="na">createLock</span><span class="p">(</span><span class="s1">&#39;charts-generation&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="c1">// ...</span>
<span class="c1">// refresh the lock for 30 seconds</span>
<span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">refresh</span><span class="p">();</span>
<span class="c1">// ...</span>
<span class="c1">// refresh the lock for 600 seconds (next refresh() call will be 30 seconds again)</span>
<span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">refresh</span><span class="p">(</span><span class="mi">600</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>This component also provides two useful methods related to expiring locks:
<code class="docutils literal notranslate"><span class="pre">getRemainingLifetime()</span></code> (which returns <code class="docutils literal notranslate"><span class="pre">null</span></code> or a <code class="docutils literal notranslate"><span class="pre">float</span></code>
as seconds) and <code class="docutils literal notranslate"><span class="pre">isExpired()</span></code> (which returns a boolean).</p>
</div>
<div class="section" id="the-owner-of-the-lock">
<h2>The Owner of The Lock</h2>
<p>Locks that are acquired for the first time are owned <a class="footnote-reference brackets" href="#id2" id="id1">1</a> by the <code class="docutils literal notranslate"><span class="pre">Lock</span></code> instance that acquired
it. If you need to check whether the current <code class="docutils literal notranslate"><span class="pre">Lock</span></code> instance is (still) the owner of
a lock, you can use the <code class="docutils literal notranslate"><span class="pre">isAcquired()</span></code> method:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">isAcquired</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// We (still) own the lock</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Because of the fact that some lock stores have expiring locks (as seen and explained
above), it is possible for an instance to lose the lock it acquired automatically:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// If we cannot acquire ourselves, it means some other process is already working on it</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">acquire</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="nv">$this</span><span class="o">-&gt;</span><span class="na">beginTransaction</span><span class="p">();</span>

<span class="c1">// Perform a very long process that might exceed TTL of the lock</span>

<span class="k">if</span> <span class="p">(</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">isAcquired</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Still all good, no other instance has acquired the lock in the meantime, we&#39;re safe</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">commit</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Bummer! Our lock has apparently exceeded TTL and another process has started in</span>
    <span class="c1">// the meantime so it&#39;s not safe for us to commit.</span>
    <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">rollback</span><span class="p">();</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nx">\Exception</span><span class="p">(</span><span class="s1">&#39;Process failed&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>A common pitfall might be to use the <code class="docutils literal notranslate"><span class="pre">isAcquired()</span></code> method to check if
a lock has already been acquired by any process. As you can see in this example
you have to use <code class="docutils literal notranslate"><span class="pre">acquire()</span></code> for this. The <code class="docutils literal notranslate"><span class="pre">isAcquired()</span></code> method is used to check
if the lock has been acquired by the <strong>current process</strong> only!</p>
</div>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Technically, the true owners of the lock are the ones that share the same instance of <code class="docutils literal notranslate"><span class="pre">Key</span></code>,
not <code class="docutils literal notranslate"><span class="pre">Lock</span></code>. But from a user perspective, <code class="docutils literal notranslate"><span class="pre">Key</span></code> is internal and you will likely only be working
with the <code class="docutils literal notranslate"><span class="pre">Lock</span></code> instance so it’s easier to think of the <code class="docutils literal notranslate"><span class="pre">Lock</span></code> instance as being the one that
is the owner of the lock.</p>
</dd>
</dl>
</div>
<div class="section" id="available-stores">
<h2>Available Stores</h2>
<p>Locks are created and managed in <code class="docutils literal notranslate"><span class="pre">Stores</span></code>, which are classes that implement
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/PersistingStoreInterface.php" title="Symfony\Component\Lock\PersistingStoreInterface"><span class="pre">PersistingStoreInterface</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/PersistingStoreInterface.php]</span></span></code> and, optionally,
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/BlockingStoreInterface.php" title="Symfony\Component\Lock\BlockingStoreInterface"><span class="pre">BlockingStoreInterface</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/BlockingStoreInterface.php]</span></span></code>.</p>
<p>The component includes the following built-in store types:</p>
<table class="docutils">
<colgroup>
<col style="width: 67%" />
<col style="width: 9%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Store</p></th>
<th class="head"><p>Scope</p></th>
<th class="head"><p>Blocking</p></th>
<th class="head"><p>Expiring</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#lock-store-flock"><span class="std std-ref">FlockStore</span></a></p></td>
<td><p>local</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lock-store-memcached"><span class="std std-ref">MemcachedStore</span></a></p></td>
<td><p>remote</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lock-store-pdo"><span class="std std-ref">PdoStore</span></a></p></td>
<td><p>remote</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lock-store-redis"><span class="std std-ref">RedisStore</span></a></p></td>
<td><p>remote</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#lock-store-semaphore"><span class="std std-ref">SemaphoreStore</span></a></p></td>
<td><p>local</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#lock-store-zookeeper"><span class="std std-ref">ZookeeperStore</span></a></p></td>
<td><p>remote</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 4.4: </span>The <code class="docutils literal notranslate"><span class="pre">PersistingStoreInterface</span></code> and <code class="docutils literal notranslate"><span class="pre">BlockingStoreInterface</span></code> interfaces were
introduced in Symfony 4.4. In previous versions there was only one interface
called <code class="docutils literal notranslate"><span class="pre">Symfony\Component\Lock\StoreInterface</span></code>.</p>
</div>
<div class="section" id="flockstore">
<span id="lock-store-flock"></span><h3>FlockStore</h3>
<p>The FlockStore uses the file system on the local computer to create the locks.
It does not support expiration, but the lock is automatically released when the
lock object goes out of scope and is freed by the garbage collector (for example
when the PHP process ends):</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\FlockStore</span><span class="p">;</span>

<span class="c1">// the argument is the path of the directory where the locks are created</span>
<span class="c1">// if none is given, sys_get_temp_dir() is used internally.</span>
<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FlockStore</span><span class="p">(</span><span class="s1">&#39;/var/stores&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Beware that some file systems (such as some types of NFS) do not support
locking. In those cases, it’s better to use a directory on a local disk
drive or a remote store based on PDO, Redis or Memcached.</p>
</div>
</div>
<div class="section" id="memcachedstore">
<span id="lock-store-memcached"></span><h3>MemcachedStore</h3>
<p>The MemcachedStore saves locks on a Memcached server, it requires a Memcached
connection implementing the <code class="docutils literal notranslate"><span class="pre">\Memcached</span></code> class. This store does not
support blocking, and expects a TTL to avoid stalled locks:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\MemcachedStore</span><span class="p">;</span>

<span class="nv">$memcached</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Memcached</span><span class="p">();</span>
<span class="nv">$memcached</span><span class="o">-&gt;</span><span class="na">addServer</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">,</span> <span class="mi">11211</span><span class="p">);</span>

<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MemcachedStore</span><span class="p">(</span><span class="nv">$memcached</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Memcached does not support TTL lower than 1 second.</p>
</div>
</div>
<div class="section" id="pdostore">
<span id="lock-store-pdo"></span><h3>PdoStore</h3>
<p>The PdoStore saves locks in an SQL database. It requires a <a class="reference external" href="https://www.php.net/pdo">PDO</a><span class="link-target"> [https://www.php.net/pdo]</span> connection, a
<a class="reference external" href="https://github.com/doctrine/dbal/blob/master/lib/Doctrine/DBAL/Connection.php">Doctrine DBAL Connection</a><span class="link-target"> [https://github.com/doctrine/dbal/blob/master/lib/Doctrine/DBAL/Connection.php]</span>, or a <a class="reference external" href="https://en.wikipedia.org/wiki/Data_source_name">Data Source Name (DSN)</a><span class="link-target"> [https://en.wikipedia.org/wiki/Data_source_name]</span>. This store does not
support blocking, and expects a TTL to avoid stalled locks:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\PdoStore</span><span class="p">;</span>

<span class="c1">// a PDO, a Doctrine DBAL connection or DSN for lazy connecting through PDO</span>
<span class="nv">$databaseConnectionOrDSN</span> <span class="o">=</span> <span class="s1">&#39;mysql:host=127.0.0.1;dbname=lock&#39;</span><span class="p">;</span>
<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PdoStore</span><span class="p">(</span><span class="nv">$databaseConnectionOrDSN</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;db_username&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;myuser&#39;</span><span class="p">,</span> <span class="s1">&#39;db_password&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;mypassword&#39;</span><span class="p">]);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This store does not support TTL lower than 1 second.</p>
</div>
<p>Before storing locks in the database, you must create the table that stores
the information. The store provides a method called
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/Store/PdoStore.php" title="Symfony\Component\Lock\Store\PdoStore::createTable()"><span class="pre">createTable()</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/Store/PdoStore.php]</span></span></code>
to set up this table for you according to the database engine used:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="p">{</span>
    <span class="nv">$store</span><span class="o">-&gt;</span><span class="na">createTable</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">\PDOException</span> <span class="nv">$exception</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// the table could not be created for some reason</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A great way to set up the table in production is to call the <code class="docutils literal notranslate"><span class="pre">createTable()</span></code>
method in your local computer and then generate a
<a class="reference internal" href="../doctrine.xhtml#doctrine-creating-the-database-tables-schema"><span class="std std-ref">database migration</span></a>:</p>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> php bin/console doctrine:migrations:diff
<span class="gp">$</span> php bin/console doctrine:migrations:migrate
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="redisstore">
<span id="lock-store-redis"></span><h3>RedisStore</h3>
<p>The RedisStore saves locks on a Redis server, it requires a Redis connection
implementing the <code class="docutils literal notranslate"><span class="pre">\Redis</span></code>, <code class="docutils literal notranslate"><span class="pre">\RedisArray</span></code>, <code class="docutils literal notranslate"><span class="pre">\RedisCluster</span></code> or
<code class="docutils literal notranslate"><span class="pre">\Predis</span></code> classes. This store does not support blocking, and expects a TTL to
avoid stalled locks:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\RedisStore</span><span class="p">;</span>

<span class="nv">$redis</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Redis</span><span class="p">();</span>
<span class="nv">$redis</span><span class="o">-&gt;</span><span class="na">connect</span><span class="p">(</span><span class="s1">&#39;localhost&#39;</span><span class="p">);</span>

<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RedisStore</span><span class="p">(</span><span class="nv">$redis</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="semaphorestore">
<span id="lock-store-semaphore"></span><h3>SemaphoreStore</h3>
<p>The SemaphoreStore uses the <a class="reference external" href="https://www.php.net/manual/en/book.sem.php">PHP semaphore functions</a><span class="link-target"> [https://www.php.net/manual/en/book.sem.php]</span> to create the locks:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\SemaphoreStore</span><span class="p">;</span>

<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SemaphoreStore</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="combinedstore">
<span id="lock-store-combined"></span><h3>CombinedStore</h3>
<p>The CombinedStore is designed for High Availability applications because it
manages several stores in sync (for example, several Redis servers). When a lock
is being acquired, it forwards the call to all the managed stores, and it
collects their responses. If a simple majority of stores have acquired the lock,
then the lock is considered as acquired; otherwise as not acquired:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\CombinedStore</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\RedisStore</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Lock\Strategy\ConsensusStrategy</span><span class="p">;</span>

<span class="nv">$stores</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">foreach</span> <span class="p">([</span><span class="s1">&#39;server1&#39;</span><span class="p">,</span> <span class="s1">&#39;server2&#39;</span><span class="p">,</span> <span class="s1">&#39;server3&#39;</span><span class="p">]</span> <span class="k">as</span> <span class="nv">$server</span><span class="p">)</span> <span class="p">{</span>
    <span class="nv">$redis</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Redis</span><span class="p">();</span>
    <span class="nv">$redis</span><span class="o">-&gt;</span><span class="na">connect</span><span class="p">(</span><span class="nv">$server</span><span class="p">);</span>

    <span class="nv">$stores</span><span class="p">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RedisStore</span><span class="p">(</span><span class="nv">$redis</span><span class="p">);</span>
<span class="p">}</span>

<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CombinedStore</span><span class="p">(</span><span class="nv">$stores</span><span class="p">,</span> <span class="k">new</span> <span class="nx">ConsensusStrategy</span><span class="p">());</span>
</pre></div>
</div>
<p>Instead of the simple majority strategy (<code class="docutils literal notranslate"><span class="pre">ConsensusStrategy</span></code>) an
<code class="docutils literal notranslate"><span class="pre">UnanimousStrategy</span></code> can be used to require the lock to be acquired in all
the stores.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>In order to get high availability when using the <code class="docutils literal notranslate"><span class="pre">ConsensusStrategy</span></code>, the
minimum cluster size must be three servers. This allows the cluster to keep
working when a single server fails (because this strategy requires that the
lock is acquired in more than half of the servers).</p>
</div>
</div>
<div class="section" id="zookeeperstore">
<span id="lock-store-zookeeper"></span><h3>ZookeeperStore</h3>
<p>The ZookeeperStore saves locks on a <a class="reference external" href="https://zookeeper.apache.org/">ZooKeeper</a><span class="link-target"> [https://zookeeper.apache.org/]</span> server. It requires a ZooKeeper
connection implementing the <code class="docutils literal notranslate"><span class="pre">\Zookeeper</span></code> class. This store does not
support blocking and expiration but the lock is automatically released when the
PHP process is terminated:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="k">use</span> <span class="nx">Symfony\Component\Lock\Store\ZookeeperStore</span><span class="p">;</span>

<span class="nv">$zookeeper</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\Zookeeper</span><span class="p">(</span><span class="s1">&#39;localhost:2181&#39;</span><span class="p">);</span>
<span class="c1">// use the following to define a high-availability cluster:</span>
<span class="c1">// $zookeeper = new \Zookeeper(&#39;localhost1:2181,localhost2:2181,localhost3:2181&#39;);</span>

<span class="nv">$store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ZookeeperStore</span><span class="p">(</span><span class="nv">$zookeeper</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Zookeeper does not require a TTL as the nodes used for locking are ephemeral
and die when the PHP process is terminated.</p>
</div>
</div>
</div>
<div class="section" id="reliability">
<h2>Reliability</h2>
<p>The component guarantees that the same resource can’t be lock twice as long as
the component is used in the following way.</p>
<div class="section" id="remote-stores">
<h3>Remote Stores</h3>
<p>Remote stores (<a class="reference internal" href="#lock-store-memcached"><span class="std std-ref">MemcachedStore</span></a>,
<a class="reference internal" href="#lock-store-pdo"><span class="std std-ref">PdoStore</span></a>,
<a class="reference internal" href="#lock-store-redis"><span class="std std-ref">RedisStore</span></a> and
<a class="reference internal" href="#lock-store-zookeeper"><span class="std std-ref">ZookeeperStore</span></a>) use a unique token to recognize
the true owner of the lock. This token is stored in the
<code class="docutils literal notranslate"><a class="reference external" href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/Key.php" title="Symfony\Component\Lock\Key"><span class="pre">Key</span></a><span class="link-target"> <span class="pre">[https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Lock/Key.php]</span></span></code> object and is used internally by
the <code class="docutils literal notranslate"><span class="pre">Lock</span></code>, therefore this key must not be shared between processes (session,
caching, fork, …).</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Do not share a key between processes.</p>
</div>
<p>Every concurrent process must store the <code class="docutils literal notranslate"><span class="pre">Lock</span></code> in the same server. Otherwise two
different machines may allow two different processes to acquire the same <code class="docutils literal notranslate"><span class="pre">Lock</span></code>.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>To guarantee that the same server will always be safe, do not use Memcached
behind a LoadBalancer, a cluster or round-robin DNS. Even if the main server
is down, the calls must not be forwarded to a backup or failover server.</p>
</div>
</div>
<div class="section" id="expiring-stores">
<h3>Expiring Stores</h3>
<p>Expiring stores (<a class="reference internal" href="#lock-store-memcached"><span class="std std-ref">MemcachedStore</span></a>,
<a class="reference internal" href="#lock-store-pdo"><span class="std std-ref">PdoStore</span></a> and
<a class="reference internal" href="#lock-store-redis"><span class="std std-ref">RedisStore</span></a>)
guarantee that the lock is acquired only for the defined duration of time. If
the task takes longer to be accomplished, then the lock can be released by the
store and acquired by someone else.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Lock</span></code> provides several methods to check its health. The <code class="docutils literal notranslate"><span class="pre">isExpired()</span></code>
method checks whether or not its lifetime is over and the <code class="docutils literal notranslate"><span class="pre">getRemainingLifetime()</span></code>
method returns its time to live in seconds.</p>
<p>Using the above methods, a more robust code would be:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// ...</span>
<span class="nv">$lock</span> <span class="o">=</span> <span class="nv">$factory</span><span class="o">-&gt;</span><span class="na">createLock</span><span class="p">(</span><span class="s1">&#39;invoice-publication&#39;</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">acquire</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nv">$finished</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">getRemainingLifetime</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">isExpired</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// lock was lost, perform a rollback or send a notification</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">\RuntimeException</span><span class="p">(</span><span class="s1">&#39;Lock lost during the overall process&#39;</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nv">$lock</span><span class="o">-&gt;</span><span class="na">refresh</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// Perform the task whose duration MUST be less than 5 minutes</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Choose wisely the lifetime of the <code class="docutils literal notranslate"><span class="pre">Lock</span></code> and check whether its remaining
time to live is enough to perform the task.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Storing a <code class="docutils literal notranslate"><span class="pre">Lock</span></code> usually takes a few milliseconds, but network conditions
may increase that time a lot (up to a few seconds). Take that into account
when choosing the right TTL.</p>
</div>
<p>By design, locks are stored in servers with a defined lifetime. If the date or
time of the machine changes, a lock could be released sooner than expected.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>To guarantee that date won’t change, the NTP service should be disabled
and the date should be updated when the service is stopped.</p>
</div>
</div>
<div class="section" id="id3">
<h3>FlockStore</h3>
<p>By using the file system, this <code class="docutils literal notranslate"><span class="pre">Store</span></code> is reliable as long as concurrent
processes use the same physical directory to stores locks.</p>
<p>Processes must run on the same machine, virtual machine or container.
Be careful when updating a Kubernetes or Swarm service because for a short
period of time, there can be two running containers in parallel.</p>
<p>The absolute path to the directory must remain the same. Be careful of symlinks
that could change at anytime: Capistrano and blue/green deployment often use
that trick. Be careful when the path to that directory changes between two
deployments.</p>
<p>Some file systems (such as some types of NFS) do not support locking.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>All concurrent processes must use the same physical file system by running
on the same machine and using the same absolute path to locks directory.</p>
<p>By definition, usage of <code class="docutils literal notranslate"><span class="pre">FlockStore</span></code> in an HTTP context is incompatible
with multiple front servers, unless to ensure that the same resource will
always be locked on the same machine or to use a well configured shared file
system.</p>
</div>
<p>Files on the file system can be removed during a maintenance operation. For instance,
to clean up the <code class="docutils literal notranslate"><span class="pre">/tmp</span></code> directory or after a reboot of the machine when a directory
uses tmpfs. It’s not an issue if the lock is released when the process ended, but
it is in case of <code class="docutils literal notranslate"><span class="pre">Lock</span></code> reused between requests.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Do not store locks on a volatile file system if they have to be reused in
several requests.</p>
</div>
</div>
<div class="section" id="id4">
<h3>MemcachedStore</h3>
<p>The way Memcached works is to store items in memory. That means that by using
the <a class="reference internal" href="#lock-store-memcached"><span class="std std-ref">MemcachedStore</span></a> the locks are not persisted
and may disappear by mistake at anytime.</p>
<p>If the Memcached service or the machine hosting it restarts, every lock would
be lost without notifying the running processes.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>To avoid that someone else acquires a lock after a restart, it’s recommended
to delay service start and wait at least as long as the longest lock TTL.</p>
</div>
<p>By default Memcached uses a LRU mechanism to remove old entries when the service
needs space to add new items.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>The number of items stored in Memcached must be under control. If it’s not
possible, LRU should be disabled and Lock should be stored in a dedicated
Memcached service away from Cache.</p>
</div>
<p>When the Memcached service is shared and used for multiple usage, Locks could be
removed by mistake. For instance some implementation of the PSR-6 <code class="docutils literal notranslate"><span class="pre">clear()</span></code>
method uses the Memcached’s <code class="docutils literal notranslate"><span class="pre">flush()</span></code> method which purges and removes everything.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>The method <code class="docutils literal notranslate"><span class="pre">flush()</span></code> must not be called, or locks should be stored in a
dedicated Memcached service away from Cache.</p>
</div>
</div>
<div class="section" id="id5">
<h3>PdoStore</h3>
<p>The PdoStore relies on the <a class="reference external" href="https://en.wikipedia.org/wiki/ACID">ACID</a><span class="link-target"> [https://en.wikipedia.org/wiki/ACID]</span> properties of the SQL engine.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>In a cluster configured with multiple primaries, ensure writes are
synchronously propagated to every nodes, or always use the same node.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Some SQL engines like MySQL allow to disable the unique constraint check.
Ensure that this is not the case <code class="docutils literal notranslate"><span class="pre">SET</span> <span class="pre">unique_checks=1;</span></code>.</p>
</div>
<p>In order to purge old locks, this store uses a current datetime to define an
expiration date reference. This mechanism relies on all server nodes to
have synchronized clocks.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>To ensure locks don’t expire prematurely; the TTLs should be set with
enough extra time to account for any clock drift between nodes.</p>
</div>
</div>
<div class="section" id="id6">
<h3>RedisStore</h3>
<p>The way Redis works is to store items in memory. That means that by using
the <a class="reference internal" href="#lock-store-redis"><span class="std std-ref">RedisStore</span></a> the locks are not persisted
and may disappear by mistake at anytime.</p>
<p>If the Redis service or the machine hosting it restarts, every locks would
be lost without notifying the running processes.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>To avoid that someone else acquires a lock after a restart, it’s recommended
to delay service start and wait at least as long as the longest lock TTL.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Redis can be configured to persist items on disk, but this option would
slow down writes on the service. This could go against other uses of the
server.</p>
</div>
<p>When the Redis service is shared and used for multiple usages, locks could be
removed by mistake.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>The command <code class="docutils literal notranslate"><span class="pre">FLUSHDB</span></code> must not be called, or locks should be stored in a
dedicated Redis service away from Cache.</p>
</div>
</div>
<div class="section" id="id7">
<h3>CombinedStore</h3>
<p>Combined stores allow to store locks across several backends. It’s a common
mistake to think that the lock mechanism will be more reliable. This is wrong.
The <code class="docutils literal notranslate"><span class="pre">CombinedStore</span></code> will be, at best, as reliable as the least reliable of
all managed stores. As soon as one managed store returns erroneous information,
the <code class="docutils literal notranslate"><span class="pre">CombinedStore</span></code> won’t be reliable.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>All concurrent processes must use the same configuration, with the same
amount of managed stored and the same endpoint.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Instead of using a cluster of Redis or Memcached servers, it’s better to use
a <code class="docutils literal notranslate"><span class="pre">CombinedStore</span></code> with a single server per managed store.</p>
</div>
</div>
<div class="section" id="id8">
<h3>SemaphoreStore</h3>
<p>Semaphores are handled by the Kernel level. In order to be reliable, processes
must run on the same machine, virtual machine or container. Be careful when
updating a Kubernetes or Swarm service because for a short period of time, there
can be two running containers in parallel.</p>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>All concurrent processes must use the same machine. Before starting a
concurrent process on a new machine, check that other process are stopped
on the old one.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>When running on systemd with non-system user and option <code class="docutils literal notranslate"><span class="pre">RemoveIPC=yes</span></code>
(default value), locks are deleted by systemd when that user logs out.
Check that process is run with a system user (UID &lt;= SYS_UID_MAX) with
<code class="docutils literal notranslate"><span class="pre">SYS_UID_MAX</span></code> defined in <code class="docutils literal notranslate"><span class="pre">/etc/login.defs</span></code>, or set the option
<code class="docutils literal notranslate"><span class="pre">RemoveIPC=off</span></code> in <code class="docutils literal notranslate"><span class="pre">/etc/systemd/logind.conf</span></code>.</p>
</div>
</div>
<div class="section" id="id9">
<h3>ZookeeperStore</h3>
<p>The way ZookeeperStore works is by maintaining locks as ephemeral nodes on the
server. That means that by using <a class="reference internal" href="#lock-store-zookeeper"><span class="std std-ref">ZookeeperStore</span></a>
the locks will be automatically released at the end of the session in case the
client cannot unlock for any reason.</p>
<p>If the ZooKeeper service or the machine hosting it restarts, every lock would
be lost without notifying the running processes.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>To use ZooKeeper’s high-availability feature, you can setup a cluster of
multiple servers so that in case one of the server goes down, the majority
will still be up and serving the requests. All the available servers in the
cluster will see the same state.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As this store does not support multi-level node locks, since the clean up of
intermediate nodes becomes an overhead, all locks are maintained at the root
level.</p>
</div>
</div>
<div class="section" id="overall">
<h3>Overall</h3>
<p>Changing the configuration of stores should be done very carefully. For
instance, during the deployment of a new version. Processes with new
configuration must not be started while old processes with old configuration
are still running.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>