<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>The Architecture</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-architecture">
<h1>The Architecture</h1>
<p>You are my hero! Who would have thought that you would still be here after the first
two parts? Your efforts will be well-rewarded soon. The first two parts didn’t look
too deeply at the architecture of the framework. Because it makes Symfony stand apart
from the framework crowd, let’s dive into the architecture now.</p>
<div class="section" id="add-logging">
<h2>Add Logging</h2>
<p>A new Symfony app is micro: it’s basically just a routing &amp; controller system. But
thanks to Flex, installing more features is simple.</p>
<p>Want a logging system? No problem:</p>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> composer require logger
</pre></div>
</td></tr></table></div>
<p>This installs and configures (via a recipe) the powerful <a class="reference external" href="https://github.com/Seldaek/monolog">Monolog</a><span class="link-target"> [https://github.com/Seldaek/monolog]</span> library. To
use the logger in a controller, add a new argument type-hinted with <code class="docutils literal notranslate"><span class="pre">LoggerInterface</span></code>:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;?</span><span class="nx">php</span>
<span class="c1">// src/Controller/DefaultController.php</span>
<span class="k">namespace</span> <span class="nx">App\Controller</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Psr\Log\LoggerInterface</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Bundle\FrameworkBundle\Controller\AbstractController</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Routing\Annotation\Route</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DefaultController</span> <span class="k">extends</span> <span class="nx">AbstractController</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * @Route(&quot;/hello/{name}&quot;)</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">index</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nx">LoggerInterface</span> <span class="nv">$logger</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$logger</span><span class="o">-&gt;</span><span class="na">info</span><span class="p">(</span><span class="s2">&quot;Saying hello to </span><span class="si">$name</span><span class="s2">!&quot;</span><span class="p">);</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That’s it! The new log message will be written to <code class="docutils literal notranslate"><span class="pre">var/log/dev.log</span></code>. The log
file path or even a different method of logging can be configured by updating
one of the config files added by the recipe.</p>
</div>
<div class="section" id="services-autowiring">
<h2>Services &amp; Autowiring</h2>
<p>But wait! Something <em>very</em> cool just happened. Symfony read the <code class="docutils literal notranslate"><span class="pre">LoggerInterface</span></code>
type-hint and automatically figured out that it should pass us the Logger object!
This is called <em>autowiring</em>.</p>
<p>Every bit of work that’s done in a Symfony app is done by an <em>object</em>: the Logger
object logs things and the Twig object renders templates. These objects are called
<em>services</em> and they are <em>tools</em> that help you build rich features.</p>
<p>To make life awesome, you can ask Symfony to pass you a service by using a type-hint.
What other possible classes or interfaces could you use? Find out by running:</p>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> php bin/console debug:autowiring

<span class="go">  # this is just a *small* sample of the output...</span>

<span class="go">  Describes a logger instance.</span>
<span class="go">  Psr\Log\LoggerInterface (monolog.logger)</span>

<span class="go">  Request stack that controls the lifecycle of requests.</span>
<span class="go">  Symfony\Component\HttpFoundation\RequestStack (request_stack)</span>

<span class="go">  Interface for the session.</span>
<span class="go">  Symfony\Component\HttpFoundation\Session\SessionInterface (session)</span>

<span class="go">  RouterInterface is the interface that all Router classes must implement.</span>
<span class="go">  Symfony\Component\Routing\RouterInterface (router.default)</span>

<span class="go">  [...]</span>
</pre></div>
</td></tr></table></div>
<p>This is just a short summary of the full list! And as you add more packages, this
list of tools will grow!</p>
</div>
<div class="section" id="creating-services">
<h2>Creating Services</h2>
<p>To keep your code organized, you can even create your own services! Suppose you
want to generate a random greeting (e.g. “Hello”, “Yo”, etc). Instead of putting
this code directly in your controller, create a new class:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;?</span><span class="nx">php</span>
<span class="c1">// src/GreetingGenerator.php</span>
<span class="k">namespace</span> <span class="nx">App</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">GreetingGenerator</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">getRandomGreeting</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nv">$greetings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hey&#39;</span><span class="p">,</span> <span class="s1">&#39;Yo&#39;</span><span class="p">,</span> <span class="s1">&#39;Aloha&#39;</span><span class="p">];</span>
        <span class="nv">$greeting</span> <span class="o">=</span> <span class="nv">$greetings</span><span class="p">[</span><span class="nb">array_rand</span><span class="p">(</span><span class="nv">$greetings</span><span class="p">)];</span>

        <span class="k">return</span> <span class="nv">$greeting</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Great! You can use this immediately in your controller:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;?</span><span class="nx">php</span>
<span class="c1">// src/Controller/DefaultController.php</span>
<span class="k">namespace</span> <span class="nx">App\Controller</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">App\GreetingGenerator</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Psr\Log\LoggerInterface</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Bundle\FrameworkBundle\Controller\AbstractController</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Symfony\Component\Routing\Annotation\Route</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">DefaultController</span> <span class="k">extends</span> <span class="nx">AbstractController</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * @Route(&quot;/hello/{name}&quot;)</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">index</span><span class="p">(</span><span class="nv">$name</span><span class="p">,</span> <span class="nx">LoggerInterface</span> <span class="nv">$logger</span><span class="p">,</span> <span class="nx">GreetingGenerator</span> <span class="nv">$generator</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$greeting</span> <span class="o">=</span> <span class="nv">$generator</span><span class="o">-&gt;</span><span class="na">getRandomGreeting</span><span class="p">();</span>

        <span class="nv">$logger</span><span class="o">-&gt;</span><span class="na">info</span><span class="p">(</span><span class="s2">&quot;Saying </span><span class="si">$greeting</span><span class="s2"> to </span><span class="si">$name</span><span class="s2">!&quot;</span><span class="p">);</span>

        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>That’s it! Symfony will instantiate the <code class="docutils literal notranslate"><span class="pre">GreetingGenerator</span></code> automatically and
pass it as an argument. But, could we <em>also</em> move the logger logic to <code class="docutils literal notranslate"><span class="pre">GreetingGenerator</span></code>?
Yes! You can use autowiring inside a service to access <em>other</em> services. The only
difference is that it’s done in the constructor:</p>
<div class="highlight-diff notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span>&lt;?php
// src/GreetingGenerator.php
<span class="gi">+ use Psr\Log\LoggerInterface;</span>

class GreetingGenerator
{
<span class="gi">+     private $logger;</span>
<span class="gi">+</span>
<span class="gi">+     public function __construct(LoggerInterface $logger)</span>
<span class="gi">+     {</span>
<span class="gi">+         $this-&gt;logger = $logger;</span>
<span class="gi">+     }</span>

    public function getRandomGreeting()
    {
        // ...

<span class="gi">+        $this-&gt;logger-&gt;info(&#39;Using the greeting: &#39;.$greeting);</span>

         return $greeting;
    }
}
</pre></div>
</td></tr></table></div>
<p>Yes! This works too: no configuration, no time wasted. Keep coding!</p>
</div>
<div class="section" id="twig-extension-autoconfiguration">
<h2>Twig Extension &amp; Autoconfiguration</h2>
<p>Thanks to Symfony’s service handling, you can <em>extend</em> Symfony in many ways, like
by creating an event subscriber or a security voter for complex authorization
rules. Let’s add a new filter to Twig called <code class="docutils literal notranslate"><span class="pre">greet</span></code>. How? Create a class
that extends <code class="docutils literal notranslate"><span class="pre">AbstractExtension</span></code>:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;?</span><span class="nx">php</span>
<span class="c1">// src/Twig/GreetExtension.php</span>
<span class="k">namespace</span> <span class="nx">App\Twig</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">App\GreetingGenerator</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Twig\Extension\AbstractExtension</span><span class="p">;</span>
<span class="k">use</span> <span class="nx">Twig\TwigFilter</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">GreetExtension</span> <span class="k">extends</span> <span class="nx">AbstractExtension</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="nv">$greetingGenerator</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">GreetingGenerator</span> <span class="nv">$greetingGenerator</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">greetingGenerator</span> <span class="o">=</span> <span class="nv">$greetingGenerator</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">getFilters</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="k">new</span> <span class="nx">TwigFilter</span><span class="p">(</span><span class="s1">&#39;greet&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">&#39;greetUser&#39;</span><span class="p">]),</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">greetUser</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$greeting</span> <span class="o">=</span>  <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">greetingGenerator</span><span class="o">-&gt;</span><span class="na">getRandomGreeting</span><span class="p">();</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">$greeting</span><span class="s2"> </span><span class="si">$name</span><span class="s2">!&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>After creating just <em>one</em> file, you can use this immediately:</p>
<div class="highlight-html+twig notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c">{# templates/default/index.html.twig #}</span>
<span class="c">{# Will print something like &quot;Hey Symfony!&quot; #}</span>
<span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="cp">{{</span> <span class="nv">name</span><span class="o">|</span><span class="nf">greet</span> <span class="cp">}}</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
</pre></div>
</td></tr></table></div>
<p>How does this work? Symfony notices that your class extends <code class="docutils literal notranslate"><span class="pre">AbstractExtension</span></code>
and so <em>automatically</em> registers it as a Twig extension. This is called autoconfiguration,
and it works for <em>many</em> many things. Create a class and then extend a base class
(or implement an interface). Symfony takes care of the rest.</p>
</div>
<div class="section" id="blazing-speed-the-cached-container">
<h2>Blazing Speed: The Cached Container</h2>
<p>After seeing how much Symfony handles automatically, you might be wondering: “Doesn’t
this hurt performance?” Actually, no! Symfony is blazing fast.</p>
<p>How is that possible? The service system is managed by a very important object called
the “container”. Most frameworks have a container, but Symfony’s is unique because
it’s <em>cached</em>. When you loaded your first page, all of the service information was
compiled and saved. This means that the autowiring and autoconfiguration features
add <em>no</em> overhead! It also means that you get <em>great</em> errors: Symfony inspects and
validates <em>everything</em> when the container is built.</p>
<p>Now you might be wondering what happens when you update a file and the cache needs
to rebuild? I like your thinking! It’s smart enough to rebuild on the next page
load. But that’s really the topic of the next section.</p>
</div>
<div class="section" id="development-versus-production-environments">
<h2>Development Versus Production: Environments</h2>
<p>One of a framework’s main jobs is to make debugging easy! And our app is <em>full</em> of
great tools for this: the web debug toolbar displays at the bottom of the page, errors
are big, beautiful &amp; explicit, and any configuration cache is automatically rebuilt
whenever needed.</p>
<p>But what about when you deploy to production? We will need to hide those tools and
optimize for speed!</p>
<p>This is solved by Symfony’s <em>environment</em> system and there are three: <code class="docutils literal notranslate"><span class="pre">dev</span></code>, <code class="docutils literal notranslate"><span class="pre">prod</span></code>
and <code class="docutils literal notranslate"><span class="pre">test</span></code>. Based on the environment, Symfony loads different files in the <code class="docutils literal notranslate"><span class="pre">config/</span></code>
directory:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span></span>config/
├─ services.yaml
├─ ...
└─ packages/
    ├─ framework.yaml
    ├─ ...
    ├─ **dev/**
        ├─ monolog.yaml
        └─ ...
    ├─ **prod/**
        └─ monolog.yaml
    └─ **test/**
        ├─ framework.yaml
        └─ ...
└─ routes/
    ├─ annotations.yaml
    └─ **dev/**
        ├─ twig.yaml
        └─ web_profiler.yaml
</pre></div>
</td></tr></table></div>
<p>This is a <em>powerful</em> idea: by changing one piece of configuration (the environment),
your app is transformed from a debugging-friendly experience to one that’s optimized
for speed.</p>
<p>Oh, how do you change the environment? Change the <code class="docutils literal notranslate"><span class="pre">APP_ENV</span></code> environment variable
from <code class="docutils literal notranslate"><span class="pre">dev</span></code> to <code class="docutils literal notranslate"><span class="pre">prod</span></code>:</p>
<div class="highlight-diff notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span># .env
<span class="gd">- APP_ENV=dev</span>
<span class="gi">+ APP_ENV=prod</span>
</pre></div>
</td></tr></table></div>
<p>But I want to talk more about environment variables next. Change the value back
to <code class="docutils literal notranslate"><span class="pre">dev</span></code>: debugging tools are great when you’re working locally.</p>
</div>
<div class="section" id="environment-variables">
<h2>Environment Variables</h2>
<p>Every app contains configuration that’s different on each server - like database
connection information or passwords. How should these be stored? In files? Or some
other way?</p>
<p>Symfony follows the industry best practice by storing server-based configuration
as <em>environment</em> variables. This means that Symfony works <em>perfectly</em> with
Platform as a Service (PaaS) deployment systems as well as Docker.</p>
<p>But setting environment variables while developing can be a pain. That’s why your
app automatically loads a <code class="docutils literal notranslate"><span class="pre">.env</span></code> file. The keys in this file then become environment
variables and are read by your app:</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># .env</span>
<span class="c1">###&gt; symfony/framework-bundle ###</span>
<span class="nv">APP_ENV</span><span class="o">=</span>dev
<span class="nv">APP_SECRET</span><span class="o">=</span>cc86c7ca937636d5ddf1b754beb22a10
<span class="c1">###&lt; symfony/framework-bundle ###</span>
</pre></div>
</td></tr></table></div>
<p>At first, the file doesn’t contain much. But as your app grows, you’ll add more
configuration as you need it. But, actually, it gets much more interesting! Suppose
your app needs a database ORM. Let’s install the Doctrine ORM:</p>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> composer require doctrine
</pre></div>
</td></tr></table></div>
<p>Thanks to a new recipe installed by Flex, look at the <code class="docutils literal notranslate"><span class="pre">.env</span></code> file again:</p>
<div class="highlight-diff notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span>###&gt; symfony/framework-bundle ###
APP_ENV=dev
APP_SECRET=cc86c7ca937636d5ddf1b754beb22a10
###&lt; symfony/framework-bundle ###

<span class="gi">+ ###&gt; doctrine/doctrine-bundle ###</span>
<span class="gi">+ # ...</span>
<span class="gi">+ DATABASE_URL=mysql://db_user:db_password@127.0.0.1:3306/db_name</span>
<span class="gi">+ ###&lt; doctrine/doctrine-bundle ###</span>
</pre></div>
</td></tr></table></div>
<p>The new <code class="docutils literal notranslate"><span class="pre">DATABASE_URL</span></code> environment variable was added <em>automatically</em> and is already
referenced by the new <code class="docutils literal notranslate"><span class="pre">doctrine.yaml</span></code> configuration file. By combining environment
variables and Flex, you’re using industry best practices without any extra effort.</p>
</div>
<div class="section" id="keep-going">
<h2>Keep Going!</h2>
<p>Call me crazy, but after reading this part, you should be comfortable with the most
<em>important</em> parts of Symfony. Everything in Symfony is designed to get out of your
way so you can keep coding and adding features, all with the speed and quality you
demand.</p>
<p>That’s all for the quick tour. From authentication, to forms, to caching, there is
so much more to discover. Ready to dig into these topics now? Look no further - go
to the official <a class="reference internal" href="../index.xhtml"><span class="doc">Symfony Documentation</span></a> and pick any guide you want.</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>