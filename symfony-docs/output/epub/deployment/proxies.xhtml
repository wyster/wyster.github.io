<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>How to Configure Symfony to Work behind a Load Balancer or a Reverse Proxy</title>
    <link rel="stylesheet" href="../_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="how-to-configure-symfony-to-work-behind-a-load-balancer-or-a-reverse-proxy">
<h1>How to Configure Symfony to Work behind a Load Balancer or a Reverse Proxy</h1>
<p>When you deploy your application, you may be behind a load balancer (e.g.
an AWS Elastic Load Balancing) or a reverse proxy (e.g. Varnish for
<a class="reference internal" href="../http_cache.xhtml"><span class="doc">caching</span></a>).</p>
<p>For the most part, this doesn’t cause any problems with Symfony. But, when
a request passes through a proxy, certain request information is sent using
either the standard <code class="docutils literal notranslate"><span class="pre">Forwarded</span></code> header or <code class="docutils literal notranslate"><span class="pre">X-Forwarded-*</span></code> headers. For example,
instead of reading the <code class="docutils literal notranslate"><span class="pre">REMOTE_ADDR</span></code> header (which will now be the IP address of
your reverse proxy), the user’s true IP will be stored in a standard <code class="docutils literal notranslate"><span class="pre">Forwarded:</span> <span class="pre">for=&quot;...&quot;</span></code>
header or a <code class="docutils literal notranslate"><span class="pre">X-Forwarded-For</span></code> header.</p>
<p>If you don’t configure Symfony to look for these headers, you’ll get incorrect
information about the client’s IP address, whether or not the client is connecting
via HTTPS, the client’s port and the hostname being requested.</p>
<div class="section" id="solution-settrustedproxies">
<span id="request-set-trusted-proxies"></span><h2>Solution: <code class="docutils literal notranslate"><span class="pre">setTrustedProxies()</span></code></h2>
<p>To fix this, you need to tell Symfony which reverse proxy IP addresses to trust
and what headers your reverse proxy uses to send information:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// public/index.php</span>

<span class="c1">// ...</span>
<span class="nv">$request</span> <span class="o">=</span> <span class="nx">Request</span><span class="o">::</span><span class="na">createFromGlobals</span><span class="p">();</span>

<span class="c1">// tell Symfony about your reverse proxy</span>
<span class="nx">Request</span><span class="o">::</span><span class="na">setTrustedProxies</span><span class="p">(</span>
    <span class="c1">// the IP address (or range) of your proxy</span>
    <span class="p">[</span><span class="s1">&#39;192.0.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;10.0.0.0/8&#39;</span><span class="p">],</span>

    <span class="c1">// trust *all* &quot;X-Forwarded-*&quot; headers</span>
    <span class="nx">Request</span><span class="o">::</span><span class="na">HEADER_X_FORWARDED_FOR</span> <span class="o">|</span> <span class="nx">Request</span><span class="o">::</span><span class="na">HEADER_X_FORWARDED_HOST</span> <span class="o">|</span> <span class="nx">Request</span><span class="o">::</span><span class="na">HEADER_X_FORWARDED_PORT</span> <span class="o">|</span> <span class="nx">Request</span><span class="o">::</span><span class="na">HEADER_X_FORWARDED_PROTO</span>

    <span class="c1">// or, if your proxy instead uses the &quot;Forwarded&quot; header</span>
    <span class="c1">// Request::HEADER_FORWARDED</span>

    <span class="c1">// or, if you&#39;re using a well-known proxy</span>
    <span class="c1">// Request::HEADER_X_FORWARDED_AWS_ELB</span>
    <span class="c1">// Request::HEADER_X_FORWARDED_TRAEFIK</span>
<span class="p">);</span>
</pre></div>
</div>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 5.2: </span>In previous Symfony versions, the above example used <code class="docutils literal notranslate"><span class="pre">HEADER_X_FORWARDED_ALL</span></code>
to trust all “X-Forwarded-” headers, but that constant is deprecated since
Symfony 5.2 in favor of the individual <code class="docutils literal notranslate"><span class="pre">HEADER_X_FORWARDED_*</span></code> constants.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>Enabling the <code class="docutils literal notranslate"><span class="pre">Request::HEADER_X_FORWARDED_HOST</span></code> option exposes the
application to <a class="reference external" href="https://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html">HTTP Host header attacks</a><span class="link-target"> [https://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html]</span>. Make sure the proxy really
sends an <code class="docutils literal notranslate"><span class="pre">x-forwarded-host</span></code> header.</p>
</div>
<p>The Request object has several <code class="docutils literal notranslate"><span class="pre">Request::HEADER_*</span></code> constants that control exactly
<em>which</em> headers from your reverse proxy are trusted. The argument is a bit field,
so you can also pass your own value (e.g. <code class="docutils literal notranslate"><span class="pre">0b00110</span></code>).</p>
</div>
<div class="section" id="but-what-if-the-ip-of-my-reverse-proxy-changes-constantly">
<h2>But what if the IP of my Reverse Proxy Changes Constantly!</h2>
<p>Some reverse proxies (like AWS Elastic Load Balancing) don’t have a
static IP address or even a range that you can target with the CIDR notation.
In this case, you’ll need to - <em>very carefully</em> - trust <em>all</em> proxies.</p>
<ol class="arabic">
<li><p>Configure your web server(s) to <em>not</em> respond to traffic from <em>any</em> clients
other than your load balancers. For AWS, this can be done with <a class="reference external" href="https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-groups.html">security groups</a><span class="link-target"> [https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-groups.html]</span>.</p></li>
<li><p>Once you’ve guaranteed that traffic will only come from your trusted reverse
proxies, configure Symfony to <em>always</em> trust incoming request:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// public/index.php</span>

<span class="c1">// ...</span>
<span class="nx">Request</span><span class="o">::</span><span class="na">setTrustedProxies</span><span class="p">(</span>
    <span class="c1">// trust *all* requests (the &#39;REMOTE_ADDR&#39; string is replaced at</span>
    <span class="c1">// run time by $_SERVER[&#39;REMOTE_ADDR&#39;])</span>
    <span class="p">[</span><span class="s1">&#39;127.0.0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;REMOTE_ADDR&#39;</span><span class="p">],</span>

    <span class="c1">// if you&#39;re using ELB, otherwise use a constant from above</span>
    <span class="nx">Request</span><span class="o">::</span><span class="na">HEADER_X_FORWARDED_AWS_ELB</span>
<span class="p">);</span>
</pre></div>
</div>
</li>
</ol>
<p>That’s it! It’s critical that you prevent traffic from all non-trusted sources.
If you allow outside traffic, they could “spoof” their true IP address and
other information.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>In applications using <a class="reference internal" href="../setup.xhtml#symfony-flex"><span class="std std-ref">Symfony Flex</span></a> you can set the
<code class="docutils literal notranslate"><span class="pre">TRUSTED_PROXIES</span></code> env var:</p>
<div class="highlight-bash notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># .env</span>
<span class="nv">TRUSTED_PROXIES</span><span class="o">=</span><span class="m">127</span>.0.0.1,REMOTE_ADDR
</pre></div>
</td></tr></table></div>
</div>
<p>If you are also using a reverse proxy on top of your load balancer (e.g.
<a class="reference external" href="https://en.wikipedia.org/wiki/Amazon_CloudFront">CloudFront</a><span class="link-target"> [https://en.wikipedia.org/wiki/Amazon_CloudFront]</span>), calling <code class="docutils literal notranslate"><span class="pre">$request-&gt;server-&gt;get('REMOTE_ADDR')</span></code> won’t be
enough, as it will only trust the node sitting directly above your application
(in this case your load balancer). You also need to append the IP addresses or
ranges of any additional proxy (e.g. <a class="reference external" href="https://ip-ranges.amazonaws.com/ip-ranges.json">CloudFront IP ranges</a><span class="link-target"> [https://ip-ranges.amazonaws.com/ip-ranges.json]</span>) to the array of
trusted proxies.</p>
</div>
<div class="section" id="custom-headers-when-using-a-reverse-proxy">
<h2>Custom Headers When Using a Reverse Proxy</h2>
<p>Some reverse proxies (like <a class="reference external" href="https://en.wikipedia.org/wiki/Amazon_CloudFront">CloudFront</a><span class="link-target"> [https://en.wikipedia.org/wiki/Amazon_CloudFront]</span> with <code class="docutils literal notranslate"><span class="pre">CloudFront-Forwarded-Proto</span></code>) may force you to use a custom header.
For instance you have <code class="docutils literal notranslate"><span class="pre">Custom-Forwarded-Proto</span></code> instead of <code class="docutils literal notranslate"><span class="pre">X-Forwarded-Proto</span></code>.</p>
<p>In this case, you’ll need to set the header <code class="docutils literal notranslate"><span class="pre">X-Forwarded-Proto</span></code> with the value of
<code class="docutils literal notranslate"><span class="pre">Custom-Forwarded-Proto</span></code> early enough in your application, i.e. before handling the request:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// public/index.php</span>

<span class="c1">// ...</span>
<span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;HTTP_X_FORWARDED_PROTO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$_SERVER</span><span class="p">[</span><span class="s1">&#39;HTTP_CUSTOM_FORWARDED_PROTO&#39;</span><span class="p">];</span>
<span class="c1">// ...</span>
<span class="nv">$response</span> <span class="o">=</span> <span class="nv">$kernel</span><span class="o">-&gt;</span><span class="na">handle</span><span class="p">(</span><span class="nv">$request</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>