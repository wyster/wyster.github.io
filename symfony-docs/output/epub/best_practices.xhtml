<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title>The Symfony Framework Best Practices</title>
    <link rel="stylesheet" href="_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/rtd_custom.css" /> 
  </head><body>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="the-symfony-framework-best-practices">
<h1>The Symfony Framework Best Practices</h1>
<p>This article describes the <strong>best practices for developing web applications with
Symfony</strong> that fit the philosophy envisioned by the original Symfony creators.</p>
<p>If you don’t agree with some of these recommendations, they might be a good
<strong>starting point</strong> that you can then <strong>extend and fit to your specific needs</strong>.
You can even ignore them completely and continue using your own best practices
and methodologies. Symfony is flexible enough to adapt to your needs.</p>
<p>This article assumes that you already have experience developing Symfony
applications. If you don’t, read first the <a class="reference internal" href="setup.xhtml"><span class="doc">Getting Started</span></a>
section of the documentation.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Symfony provides a sample application called <a class="reference external" href="https://github.com/symfony/demo">Symfony Demo</a><span class="link-target"> [https://github.com/symfony/demo]</span> that follows
all these best practices, so you can experience them in practice.</p>
</div>
<div class="section" id="creating-the-project">
<h2>Creating the Project</h2>
<div class="section" id="use-the-symfony-binary-to-create-symfony-applications">
<h3>Use the Symfony Binary to Create Symfony Applications</h3>
<p>The Symfony binary is an executable command created in your machine when you
<a class="reference external" href="https://symfony.com/download">download Symfony</a><span class="link-target"> [https://symfony.com/download]</span>. It provides multiple utilities, including the simplest way
to create new Symfony applications:</p>
<div class="highlight-terminal notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">$</span> symfony new my_project_name
</pre></div>
</td></tr></table></div>
<p>Under the hood, this Symfony binary command executes the needed <a class="reference external" href="https://getcomposer.org/">Composer</a><span class="link-target"> [https://getcomposer.org/]</span>
command to <a class="reference internal" href="setup.xhtml#creating-symfony-applications"><span class="std std-ref">create a new Symfony application</span></a>
based on the current stable version.</p>
</div>
<div class="section" id="use-the-default-directory-structure">
<h3>Use the Default Directory Structure</h3>
<p>Unless your project follows a development practice that imposes a certain
directory structure, follow the default Symfony directory structure. It’s flat,
self-explanatory and not coupled to Symfony:</p>
<div class="highlight-text notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span>your_project/
├─ assets/
├─ bin/
│  └─ console
├─ config/
│  ├─ packages/
│  └─ services.yaml
├─ migrations/
├─ public/
│  ├─ build/
│  └─ index.php
├─ src/
│  ├─ Kernel.php
│  ├─ Command/
│  ├─ Controller/
│  ├─ DataFixtures/
│  ├─ Entity/
│  ├─ EventSubscriber/
│  ├─ Form/
│  ├─ Repository/
│  ├─ Security/
│  └─ Twig/
├─ templates/
├─ tests/
├─ translations/
├─ var/
│  ├─ cache/
│  └─ log/
└─ vendor/
</pre></div>
</td></tr></table></div>
</div>
</div>
<div class="section" id="configuration">
<h2>Configuration</h2>
<div class="section" id="use-environment-variables-for-infrastructure-configuration">
<h3>Use Environment Variables for Infrastructure Configuration</h3>
<p>The values of these options change from one machine to another (e.g. from your
development machine to the production server) but they don’t modify the
application behavior.</p>
<p><a class="reference internal" href="configuration.xhtml#config-env-vars"><span class="std std-ref">Use env vars in your project</span></a> to define these options
and create multiple <code class="docutils literal notranslate"><span class="pre">.env</span></code> files to <a class="reference internal" href="configuration.xhtml#config-dot-env"><span class="std std-ref">configure env vars per environment</span></a>.</p>
</div>
<div class="section" id="use-secret-for-sensitive-information">
<h3>Use Secret for Sensitive Information</h3>
<p>When your application has sensitive configuration - like an API key - you should
store those securely via <a class="reference internal" href="configuration/secrets.xhtml"><span class="doc">Symfony’s secrets management system</span></a>.</p>
</div>
<div class="section" id="use-parameters-for-application-configuration">
<h3>Use Parameters for Application Configuration</h3>
<p>These are the options used to modify the application behavior, such as the sender
of email notifications, or the enabled <a class="reference external" href="https://en.wikipedia.org/wiki/Feature_toggle">feature toggles</a><span class="link-target"> [https://en.wikipedia.org/wiki/Feature_toggle]</span>. Their value doesn’t
change per machine, so don’t define them as environment variables.</p>
<p>Define these options as <a class="reference internal" href="configuration.xhtml#configuration-parameters"><span class="std std-ref">parameters</span></a> in the
<code class="docutils literal notranslate"><span class="pre">config/services.yaml</span></code> file. You can override these options per
<a class="reference internal" href="configuration.xhtml#configuration-environments"><span class="std std-ref">environment</span></a> in the <code class="docutils literal notranslate"><span class="pre">config/services_dev.yaml</span></code>
and <code class="docutils literal notranslate"><span class="pre">config/services_prod.yaml</span></code> files.</p>
</div>
<div class="section" id="use-short-and-prefixed-parameter-names">
<h3>Use Short and Prefixed Parameter Names</h3>
<p>Consider using <code class="docutils literal notranslate"><span class="pre">app.</span></code> as the prefix of your <a class="reference internal" href="configuration.xhtml#configuration-parameters"><span class="std std-ref">parameters</span></a>
to avoid collisions with Symfony and third-party bundles/libraries parameters.
Then, use just one or two words to describe the purpose of the parameter:</p>
<div class="highlight-yaml notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># config/services.yaml</span>
<span class="l l-Scalar l-Scalar-Plain">parameters</span><span class="p p-Indicator">:</span>
    <span class="c1"># don&#39;t do this: &#39;dir&#39; is too generic and it doesn&#39;t convey any meaning</span>
    <span class="l l-Scalar l-Scalar-Plain">app.dir</span><span class="p p-Indicator">:</span> <span class="s">&#39;...&#39;</span>
    <span class="c1"># do this: short but easy to understand names</span>
    <span class="l l-Scalar l-Scalar-Plain">app.contents_dir</span><span class="p p-Indicator">:</span> <span class="s">&#39;...&#39;</span>
    <span class="c1"># it&#39;s OK to use dots, underscores, dashes or nothing, but always</span>
    <span class="c1"># be consistent and use the same format for all the parameters</span>
    <span class="l l-Scalar l-Scalar-Plain">app.dir.contents</span><span class="p p-Indicator">:</span> <span class="s">&#39;...&#39;</span>
    <span class="l l-Scalar l-Scalar-Plain">app.contents-dir</span><span class="p p-Indicator">:</span> <span class="s">&#39;...&#39;</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="use-constants-to-define-options-that-rarely-change">
<h3>Use Constants to Define Options that Rarely Change</h3>
<p>Configuration options like the number of items to display in some listing rarely
change. Instead of defining them as <a class="reference internal" href="configuration.xhtml#configuration-parameters"><span class="std std-ref">service container parameters</span></a>,
define them as PHP constants in the related classes. Example:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// src/Entity/Post.php</span>
<span class="k">namespace</span> <span class="nx">App\Entity</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Post</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">const</span> <span class="no">NUMBER_OF_ITEMS</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main advantage of constants is that you can use them everywhere, including
Twig templates and Doctrine entities, whereas parameters are only available
from places with access to the <a class="reference internal" href="service_container.xhtml"><span class="doc">service container</span></a>.</p>
<p>The only notable disadvantage of using constants for this kind of configuration
values is that it’s complicated to redefine their values in your tests.</p>
</div>
</div>
<div class="section" id="business-logic">
<h2>Business Logic</h2>
<div class="section" id="don-t-create-any-bundle-to-organize-your-application-logic">
<h3>Don’t Create any Bundle to Organize your Application Logic</h3>
<p>When Symfony 2.0 was released, applications used <a class="reference internal" href="bundles.xhtml"><span class="doc">bundles</span></a> to
divide their code into logical features: UserBundle, ProductBundle,
InvoiceBundle, etc. However, a bundle is meant to be something that can be
reused as a stand-alone piece of software.</p>
<p>If you need to reuse some feature in your projects, create a bundle for it (in a
private repository, to not make it publicly available). For the rest of your
application code, use PHP namespaces to organize code instead of bundles.</p>
</div>
<div class="section" id="use-autowiring-to-automate-the-configuration-of-application-services">
<h3>Use Autowiring to Automate the Configuration of Application Services</h3>
<p><a class="reference internal" href="service_container/autowiring.xhtml"><span class="doc">Service autowiring</span></a> is a feature that
reads the type-hints on your constructor (or other methods) and automatically
passes the correct services to each method, making unnecessary to configure
services explicitly and simplifying the application maintenance.</p>
<p>Use it in combination with <a class="reference internal" href="service_container.xhtml#services-autoconfigure"><span class="std std-ref">service autoconfiguration</span></a>
to also add <a class="reference internal" href="service_container/tags.xhtml"><span class="doc">service tags</span></a> to the services
needing them, such as Twig extensions, event subscribers, etc.</p>
</div>
<div class="section" id="services-should-be-private-whenever-possible">
<h3>Services Should be Private Whenever Possible</h3>
<p><a class="reference internal" href="service_container.xhtml#container-public"><span class="std std-ref">Make services private</span></a> to prevent you from accessing
those services via <code class="docutils literal notranslate"><span class="pre">$container-&gt;get()</span></code>. Instead, you will need to use proper
dependency injection.</p>
</div>
<div class="section" id="use-the-yaml-format-to-configure-your-own-services">
<h3>Use the YAML Format to Configure your Own Services</h3>
<p>If you use the <a class="reference internal" href="service_container.xhtml#service-container-services-load-example"><span class="std std-ref">default services.yaml configuration</span></a>,
most services will be configured automatically. However, in some edge cases
you’ll need to configure services (or parts of them) manually.</p>
<p>YAML is the format recommended to configure services because it’s friendly to
newcomers and concise, but Symfony also supports XML and PHP configuration.</p>
</div>
<div class="section" id="use-annotations-to-define-the-doctrine-entity-mapping">
<h3>Use Annotations to Define the Doctrine Entity Mapping</h3>
<p>Doctrine entities are plain PHP objects that you store in some “database”.
Doctrine only knows about your entities through the mapping metadata configured
for your model classes.</p>
<p>Doctrine supports several metadata formats, but it’s recommended to use
annotations because they are by far the most convenient and agile way of setting
up and looking for mapping information.</p>
</div>
</div>
<div class="section" id="controllers">
<h2>Controllers</h2>
<div class="section" id="make-your-controller-extend-the-abstractcontroller-base-controller">
<h3>Make your Controller Extend the <code class="docutils literal notranslate"><span class="pre">AbstractController</span></code> Base Controller</h3>
<p>Symfony provides a <a class="reference internal" href="controller.xhtml#the-base-controller-classes-services"><span class="std std-ref">base controller</span></a>
which includes shortcuts for the most common needs such as rendering templates
or checking security permissions.</p>
<p>Extending your controllers from this base controller couples your application
to Symfony. Coupling is generally wrong, but it may be OK in this case because
controllers shouldn’t contain any business logic. Controllers should contain
nothing more than a few lines of <em>glue-code</em>, so you are not coupling the
important parts of your application.</p>
</div>
<div class="section" id="use-annotations-to-configure-routing-caching-and-security">
<span id="best-practice-controller-annotations"></span><h3>Use Annotations to Configure Routing, Caching and Security</h3>
<p>Using annotations for routing, caching and security simplifies configuration.
You don’t need to browse several files created with different formats (YAML, XML,
PHP): all the configuration is just where you need it and it only uses one format.</p>
</div>
<div class="section" id="don-t-use-annotations-to-configure-the-controller-template">
<h3>Don’t Use Annotations to Configure the Controller Template</h3>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;Template</span></code> annotation is useful, but also involves some <em>magic</em>.
Moreover, most of the time <code class="docutils literal notranslate"><span class="pre">&#64;Template</span></code> is used without any parameters, which
makes it more difficult to know which template is being rendered. It also hides
the fact that a controller should always return a <code class="docutils literal notranslate"><span class="pre">Response</span></code> object.</p>
</div>
<div class="section" id="use-dependency-injection-to-get-services">
<h3>Use Dependency Injection to Get Services</h3>
<p>If you extend the base <code class="docutils literal notranslate"><span class="pre">AbstractController</span></code>, you can only access to the most
common services (e.g <code class="docutils literal notranslate"><span class="pre">twig</span></code>, <code class="docutils literal notranslate"><span class="pre">router</span></code>, <code class="docutils literal notranslate"><span class="pre">doctrine</span></code>, etc.), directly from the
container via <code class="docutils literal notranslate"><span class="pre">$this-&gt;container-&gt;get()</span></code> or <code class="docutils literal notranslate"><span class="pre">$this-&gt;get()</span></code>.
Instead, you must use dependency injection to fetch services by
<a class="reference internal" href="controller.xhtml#controller-accessing-services"><span class="std std-ref">type-hinting action method arguments</span></a> or
constructor arguments.</p>
</div>
<div class="section" id="use-paramconverters-if-they-are-convenient">
<h3>Use ParamConverters If They Are Convenient</h3>
<p>If you’re using <a class="reference internal" href="doctrine.xhtml"><span class="doc">Doctrine</span></a>, then you can <em>optionally</em> use the
<a class="reference external" href="https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html">ParamConverter</a><span class="link-target"> [https://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/annotations/converters.html]</span> to automatically query for an entity and pass it as an argument
to your controller. It will also show a 404 page if no entity can be found.</p>
<p>If the logic to get an entity from a route variable is more complex, instead of
configuring the ParamConverter, it’s better to make the Doctrine query inside
the controller (e.g. by calling to a <a class="reference internal" href="doctrine.xhtml"><span class="doc">Doctrine repository method</span></a>).</p>
</div>
</div>
<div class="section" id="templates">
<h2>Templates</h2>
<div class="section" id="use-snake-case-for-template-names-and-variables">
<h3>Use Snake Case for Template Names and Variables</h3>
<p>Use lowercased snake_case for template names, directories and variables (e.g.
<code class="docutils literal notranslate"><span class="pre">user_profile</span></code> instead of <code class="docutils literal notranslate"><span class="pre">userProfile</span></code> and <code class="docutils literal notranslate"><span class="pre">product/edit_form.html.twig</span></code>
instead of <code class="docutils literal notranslate"><span class="pre">Product/EditForm.html.twig</span></code>).</p>
</div>
<div class="section" id="prefix-template-fragments-with-an-underscore">
<h3>Prefix Template Fragments with an Underscore</h3>
<p>Template fragments, also called <em>“partial templates”</em>, allow to
<a class="reference internal" href="templates.xhtml#templates-reuse-contents"><span class="std std-ref">reuse template contents</span></a>. Prefix their names
with an underscore to better differentiate them from complete templates (e.g.
<code class="docutils literal notranslate"><span class="pre">_user_metadata.html.twig</span></code> or <code class="docutils literal notranslate"><span class="pre">_caution_message.html.twig</span></code>).</p>
</div>
</div>
<div class="section" id="forms">
<h2>Forms</h2>
<div class="section" id="define-your-forms-as-php-classes">
<h3>Define your Forms as PHP Classes</h3>
<p>Creating <a class="reference internal" href="forms.xhtml#creating-forms-in-classes"><span class="std std-ref">forms in classes</span></a> allows to reuse
them in different parts of the application. Besides, not creating forms in
controllers simplify the code and maintenance of the controllers.</p>
</div>
<div class="section" id="add-form-buttons-in-templates">
<h3>Add Form Buttons in Templates</h3>
<p>Form classes should be agnostic to where they will be used. For example, the
button of a form used to both create and edit items should change from “Add new”
to “Save changes” depending on where it’s used.</p>
<p>Instead of adding buttons in form classes or the controllers, it’s recommended
to add buttons in the templates. This also improves the separation of concerns,
because the button styling (CSS class and other attributes) is defined in the
template instead of in a PHP class.</p>
<p>However, if you create a <a class="reference internal" href="form/multiple_buttons.xhtml"><span class="doc">form with multiple submit buttons</span></a>
you should define them in the controller instead of the template. Otherwise, you
won’t be able to check which button was clicked when handling the form in the controller.</p>
</div>
<div class="section" id="define-validation-constraints-on-the-underlying-object">
<h3>Define Validation Constraints on the Underlying Object</h3>
<p>Attaching <a class="reference internal" href="reference/constraints.xhtml"><span class="doc">validation constraints</span></a> to form fields
instead of to the mapped object prevents the validation from being reused in
other forms or other places where the object is used.</p>
</div>
<div class="section" id="use-a-single-action-to-render-and-process-the-form">
<span id="best-practice-handle-form"></span><h3>Use a Single Action to Render and Process the Form</h3>
<p><a class="reference internal" href="forms.xhtml#rendering-forms"><span class="std std-ref">Rendering forms</span></a> and <a class="reference internal" href="forms.xhtml#processing-forms"><span class="std std-ref">processing forms</span></a>
are two of the main tasks when handling forms. Both are too similar (most of the
times, almost identical), so it’s much simpler to let a single controller action
handle both.</p>
</div>
</div>
<div class="section" id="internationalization">
<h2>Internationalization</h2>
<div class="section" id="use-the-xliff-format-for-your-translation-files">
<h3>Use the XLIFF Format for Your Translation Files</h3>
<p>Of all the translation formats supported by Symfony (PHP, Qt, <code class="docutils literal notranslate"><span class="pre">.po</span></code>, <code class="docutils literal notranslate"><span class="pre">.mo</span></code>,
JSON, CSV, INI, etc.), <code class="docutils literal notranslate"><span class="pre">XLIFF</span></code> and <code class="docutils literal notranslate"><span class="pre">gettext</span></code> have the best support in the tools used
by professional translators. And since it’s based on XML, you can validate <code class="docutils literal notranslate"><span class="pre">XLIFF</span></code>
file contents as you write them.</p>
<p>Symfony also supports notes in XLIFF files, making them more user-friendly for
translators. At the end, good translations are all about context, and these
XLIFF notes allow you to define that context.</p>
</div>
<div class="section" id="use-keys-for-translations-instead-of-content-strings">
<h3>Use Keys for Translations Instead of Content Strings</h3>
<p>Using keys simplifies the management of the translation files because you can
change the original contents in templates, controllers and services without
having to update all of the translation files.</p>
<p>Keys should always describe their <em>purpose</em> and <em>not</em> their location. For
example, if a form has a field with the label “Username”, then a nice key
would be <code class="docutils literal notranslate"><span class="pre">label.username</span></code>, <em>not</em> <code class="docutils literal notranslate"><span class="pre">edit_form.label.username</span></code>.</p>
</div>
</div>
<div class="section" id="security">
<h2>Security</h2>
<div class="section" id="define-a-single-firewall">
<h3>Define a Single Firewall</h3>
<p>Unless you have two legitimately different authentication systems and users
(e.g. form login for the main site and a token system for your API only), it’s
recommended to have only one firewall to keep things simple.</p>
<p>Additionally, you should use the <code class="docutils literal notranslate"><span class="pre">anonymous</span></code> key under your firewall. If you
require users to be logged in for different sections of your site, use the
<a class="reference internal" href="security/access_control.xhtml"><span class="doc">access_control</span></a> option.</p>
</div>
<div class="section" id="use-the-auto-password-hasher">
<h3>Use the <code class="docutils literal notranslate"><span class="pre">auto</span></code> Password Hasher</h3>
<p>The <a class="reference internal" href="reference/configuration/security.xhtml#reference-security-encoder-auto"><span class="std std-ref">auto password hasher</span></a> automatically
selects the best possible encoder/hasher depending on your PHP installation.
Currently, it tries to use <code class="docutils literal notranslate"><span class="pre">sodium</span></code> by default and falls back to <code class="docutils literal notranslate"><span class="pre">bcrypt</span></code>.</p>
</div>
<div class="section" id="use-voters-to-implement-fine-grained-security-restrictions">
<h3>Use Voters to Implement Fine-grained Security Restrictions</h3>
<p>If your security logic is complex, you should create custom
<a class="reference internal" href="security/voters.xhtml"><span class="doc">security voters</span></a> instead of defining long expressions
inside the <code class="docutils literal notranslate"><span class="pre">&#64;Security</span></code> annotation.</p>
</div>
</div>
<div class="section" id="web-assets">
<h2>Web Assets</h2>
<div class="section" id="use-webpack-encore-to-process-web-assets">
<h3>Use Webpack Encore to Process Web Assets</h3>
<p>Web assets are things like CSS, JavaScript and image files that make the
frontend of your site look and work great. <a class="reference external" href="https://webpack.js.org/">Webpack</a><span class="link-target"> [https://webpack.js.org/]</span> is the leading JavaScript
module bundler that compiles, transforms and packages assets for usage in a browser.</p>
<p><a class="reference internal" href="frontend.xhtml"><span class="doc">Webpack Encore</span></a> is a JavaScript library that gets rid of most
of Webpack complexity without hiding any of its features or distorting its usage
and philosophy. It was originally created for Symfony applications, but it works
for any application using any technology.</p>
</div>
</div>
<div class="section" id="tests">
<h2>Tests</h2>
<div class="section" id="smoke-test-your-urls">
<h3>Smoke Test your URLs</h3>
<p>In software engineering, <a class="reference external" href="https://en.wikipedia.org/wiki/Smoke_testing_(software)">smoke testing</a><span class="link-target"> [https://en.wikipedia.org/wiki/Smoke_testing_(software)]</span> consists of <em>“preliminary testing to
reveal simple failures severe enough to reject a prospective software release”</em>.
Using <a class="reference internal" href="testing.xhtml#testing-data-providers"><span class="std std-ref">PHPUnit data providers</span></a> you can define a
functional test that checks that all application URLs load successfully:</p>
<div class="highlight-php notranslate"><div class="highlight"><pre><span></span><span class="c1">// tests/ApplicationAvailabilityFunctionalTest.php</span>
<span class="k">namespace</span> <span class="nx">App\Tests</span><span class="p">;</span>

<span class="k">use</span> <span class="nx">Symfony\Bundle\FrameworkBundle\Test\WebTestCase</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ApplicationAvailabilityFunctionalTest</span> <span class="k">extends</span> <span class="nx">WebTestCase</span>
<span class="p">{</span>
    <span class="sd">/**</span>
<span class="sd">     * @dataProvider urlProvider</span>
<span class="sd">     */</span>
    <span class="k">public</span> <span class="k">function</span> <span class="nf">testPageIsSuccessful</span><span class="p">(</span><span class="nv">$url</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nv">$client</span> <span class="o">=</span> <span class="nx">self</span><span class="o">::</span><span class="na">createClient</span><span class="p">();</span>
        <span class="nv">$client</span><span class="o">-&gt;</span><span class="na">request</span><span class="p">(</span><span class="s1">&#39;GET&#39;</span><span class="p">,</span> <span class="nv">$url</span><span class="p">);</span>

        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">assertResponseIsSuccessful</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">function</span> <span class="nf">urlProvider</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">yield</span> <span class="p">[</span><span class="s1">&#39;/&#39;</span><span class="p">];</span>
        <span class="k">yield</span> <span class="p">[</span><span class="s1">&#39;/posts&#39;</span><span class="p">];</span>
        <span class="k">yield</span> <span class="p">[</span><span class="s1">&#39;/post/fixture-post-1&#39;</span><span class="p">];</span>
        <span class="k">yield</span> <span class="p">[</span><span class="s1">&#39;/blog/category/fixture-category&#39;</span><span class="p">];</span>
        <span class="k">yield</span> <span class="p">[</span><span class="s1">&#39;/archives&#39;</span><span class="p">];</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Add this test while creating your application because it requires little effort
and checks that none of your pages returns an error. Later, you’ll add more
specific tests for each page.</p>
</div>
<div class="section" id="hardcode-urls-in-a-functional-test">
<h3>Hardcode URLs in a Functional Test</h3>
<p>In Symfony applications, it’s recommended to <a class="reference internal" href="routing.xhtml#routing-generating-urls"><span class="std std-ref">generate URLs</span></a>
using routes to automatically update all links when a URL changes. However, if a
public URL changes, users won’t be able to browse it unless you set up a
redirection to the new URL.</p>
<p>That’s why it’s recommended to use raw URLs in tests instead of generating them
from routes. Whenever a route changes, tests will fail and you’ll know that
you must set up a redirection.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>